commit a9e55b39618ae778342bc6d5806d4590bbb5d343
Author: Anuma Rathore <arathore@nvidia.com>
Date:   Wed Feb 3 23:51:31 2021 -0800

    0003-H264-VP8-VP9-Jetson-HW-Dec-acceleration.patch
    
    Chrome 90.0.4400.4

diff --git a/content/gpu/gpu_sandbox_hook_linux.cc b/content/gpu/gpu_sandbox_hook_linux.cc
index d2fd587..ce5bcc4 100644
--- a/content/gpu/gpu_sandbox_hook_linux.cc
+++ b/content/gpu/gpu_sandbox_hook_linux.cc
@@ -81,6 +81,14 @@ inline bool UseLibV4L2() {
 #endif
 }
 
+inline bool UseNvidiaV4L2() {
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  return true;
+#else
+  return false;
+#endif
+}
+
 #if BUILDFLAG(IS_CHROMEOS_ASH) && defined(__aarch64__)
 static const char kLibGlesPath[] = "/usr/lib64/libGLESv2.so.2";
 static const char kLibEglPath[] = "/usr/lib64/libEGL.so.1";
@@ -386,6 +394,11 @@ void LoadArmGpuLibraries() {
     // Preload the Tegra V4L2 (video decode acceleration) library.
     dlopen(kLibTegraPath, dlopen_flag);
   }
+  // nvbuf_utils is used only in v4l2-based decoder, but it could
+  // be used for other purposes
+  if (UseNvidiaV4L2()) {
+    dlopen("/usr/lib/aarch64-linux-gnu/tegra/libnvbuf_utils.so", dlopen_flag);
+   }
 }
 
 bool LoadAmdGpuLibraries() {
diff --git a/media/gpu/BUILD.gn b/media/gpu/BUILD.gn
index e317b83..07e68ae 100644
--- a/media/gpu/BUILD.gn
+++ b/media/gpu/BUILD.gn
@@ -21,9 +21,46 @@ buildflag_header("buildflags") {
     "USE_V4L2_CODEC=$use_v4l2_codec",
     "USE_LIBV4L2=$use_v4lplugin",
     "USE_LINUX_V4L2=$use_linux_v4l2_only",
+    "USE_NVIDIA_V4L2=$use_nvidia_v4l2",
   ]
 }
 
+if (use_nvidia_v4l2) {
+  action("libnvbuf_utils_generate_stubs") {
+    extra_header = "nvbuf/nvbufutils_stub_header.fragment"
+
+    script = "../../tools/generate_stubs/generate_stubs.py"
+    sources = [
+      "nvbuf/nvbuf.sig",
+    ]
+    inputs = [
+      extra_header,
+    ]
+    stubs_filename_root = "nvbuf_stubs"
+
+    outputs = [
+      "$target_gen_dir/nvbuf/$stubs_filename_root.cc",
+      "$target_gen_dir/nvbuf/$stubs_filename_root.h",
+    ]
+    args = [
+      "-i",
+      rebase_path("$target_gen_dir/nvbuf", root_build_dir),
+      "-o",
+      rebase_path("$target_gen_dir/nvbuf", root_build_dir),
+      "-t",
+      "posix_stubs",
+      "-e",
+      rebase_path(extra_header, root_build_dir),
+      "-s",
+      stubs_filename_root,
+      "-p",
+      "media/gpu/nvbuf",
+    ]
+
+    args += rebase_path(sources, root_build_dir)
+  }
+}
+
 component("gpu") {
   output_name = "media_gpu"
 
@@ -168,6 +205,11 @@ component("gpu") {
     ]
   }
 
+  if (use_nvidia_v4l2) {
+    sources += get_target_outputs(":libnvbuf_utils_generate_stubs")
+    deps += [ ":libnvbuf_utils_generate_stubs" ]
+  }
+
   if (is_win) {
     sources += [
       "windows/av1_guids.h",
diff --git a/media/gpu/args.gni b/media/gpu/args.gni
index b47d9fb..d5aeae7 100644
--- a/media/gpu/args.gni
+++ b/media/gpu/args.gni
@@ -21,6 +21,10 @@ declare_args() {
   # platforms which have v4l2 hardware encoder
   use_v4l2_codec_aml = false
 
+  # Indicates if NVIDIA Tegra codec path is used.
+  # This is used on Tegra platforms for hardware decode
+  use_nvidia_v4l2 = false
+
   # Indicates if VA-API-based hardware acceleration is to be used. This
   # is typically the case on x86-based ChromeOS devices.
   # VA-API should also be compiled by default on x11-using linux devices
diff --git a/media/gpu/nvbuf/nvbuf.sig b/media/gpu/nvbuf/nvbuf.sig
new file mode 100644
index 0000000..a8cf263
--- /dev/null
+++ b/media/gpu/nvbuf/nvbuf.sig
@@ -0,0 +1,16 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+//---------------------------------------------------
+// Functions from libnvbuf_utils used in chromium code.
+//---------------------------------------------------
+EGLImageKHR NvEGLImageFromFd (EGLDisplay display, int dmabuf_fd);
+int NvDestroyEGLImage (EGLDisplay display, EGLImageKHR eglImage);
+int NvBufferCreateEx (int *dmabuf_fd, NvBufferCreateParams *input_params);
+int NvBufferGetParams (int dmabuf_fd, NvBufferParams *params);
+int NvBufferDestroy (int dmabuf_fd);
+int NvBufferMemSyncForCpu (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+int NvBufferMemMap (int dmabuf_fd, unsigned int plane, NvBufferMemFlags memflag, void **pVirtAddr);
+int NvBufferMemUnMap (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+int NvBuffer2Raw (int dmabuf_fd, unsigned int plane, unsigned int out_width, unsigned int out_height, unsigned char *ptr);
diff --git a/media/gpu/nvbuf/nvbuf_utils.h b/media/gpu/nvbuf/nvbuf_utils.h
new file mode 100644
index 0000000..1453f17
--- /dev/null
+++ b/media/gpu/nvbuf/nvbuf_utils.h
@@ -0,0 +1,810 @@
+/*
+ * Copyright (c) 2016-2020, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * NVIDIA Corporation and its licensors retain all intellectual property
+ * and proprietary rights in and to this software, related documentation
+ * and any modifications thereto.  Any use, reproduction, disclosure or
+ * distribution of this software and related documentation without an express
+ * license agreement from NVIDIA Corporation is strictly prohibited.
+ */
+
+/**
+ * @file
+ * <b>NVIDIA Multimedia Utilities: Buffering and Transform/Composition/Blending</b>
+ *
+ */
+
+/**
+ * @defgroup ee_nvbuffering_group Buffer Manager
+ * @ingroup common_utility_group
+ * NVIDIA buffering utility library for use by applications.
+ * The utility also transforms, composits, and blends.
+ * @{
+ */
+
+#ifndef _NVBUF_UTILS_H_
+#define _NVBUF_UTILS_H_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <errno.h>
+#include <stdbool.h>
+
+/**
+ * Defines the maximum number of planes for a video frame.
+ */
+#define MAX_NUM_PLANES 4
+
+/**
+ * Defines the maximum number of input video frames that can be used for composition.
+ */
+#define MAX_COMPOSITE_FRAME 16
+
+/**
+ * Defines the default values for chroma subsampling.
+ * The default value matches JPEG/MPEG use cases.
+ */
+#define NVBUF_CHROMA_SUBSAMPLING_HORIZ_DEFAULT 0
+#define NVBUF_CHROMA_SUBSAMPLING_VERT_DEFAULT 1
+
+/**
+ * Defines the maximum number of sync object parameters.
+ */
+#define NVBUF_MAX_SYNCOBJ_PARAMS 5
+
+/**
+ * Use this value to represent an infinite wait interval.
+ * A value of zero should not be interpreted as infinite,
+ * it should be interpreted as "time out immediately" and
+ * simply check whether the event has already happened.
+ */
+#define NVBUFFER_SYNCPOINT_WAIT_INFINITE 0xFFFFFFFF
+
+/**
+ * Defines Payload types for NvBuffer.
+ */
+typedef enum
+{
+  /** buffer payload with HW memory handle for set of planes. */
+  NvBufferPayload_SurfArray,
+  /** buffer payload with HW memory handle for specific memory size. */
+  NvBufferPayload_MemHandle,
+} NvBufferPayloadType;
+
+/**
+ * Defines display scan formats for NvBuffer video planes.
+ */
+typedef enum
+{
+  /** Progessive scan formats. */
+  NvBufferDisplayScanFormat_Progressive = 0,
+  /** Interlaced scan formats. */
+  NvBufferDisplayScanFormat_Interlaced,
+} NvBufferDisplayScanFormat;
+
+/**
+ * Defines Layout formats for NvBuffer video planes.
+ */
+typedef enum
+{
+  /** Pitch Layout. */
+  NvBufferLayout_Pitch,
+  /** BlockLinear Layout. */
+  NvBufferLayout_BlockLinear,
+} NvBufferLayout;
+
+/**
+ * Defines memory access flags for NvBuffer.
+ */
+typedef enum
+{
+  /** Memory read. */
+  NvBufferMem_Read,
+  /** Memory write. */
+  NvBufferMem_Write,
+  /** Memory read & write. */
+  NvBufferMem_Read_Write,
+} NvBufferMemFlags;
+
+/**
+ * Defines tags that identify the components requesting a memory allocation.
+ * The tags can be used later to identify the total memory allocated to
+ * particular types of components.
+ */
+typedef enum
+{
+  /** tag None. */
+  NvBufferTag_NONE            = 0x0,
+  /** tag for Camera. */
+  NvBufferTag_CAMERA          = 0x200,
+  /** tag for Jpeg Encoder/Decoder. */
+  NvBufferTag_JPEG            = 0x1500,
+  /** tag for VPR Buffers. */
+  NvBufferTag_PROTECTED       = 0x1504,
+  /** tag for H264/H265 Video Encoder. */
+  NvBufferTag_VIDEO_ENC       = 0x1200,
+  /** tag for H264/H265/VP9 Video Decoder. */
+  NvBufferTag_VIDEO_DEC       = 0x1400,
+  /** tag for Video Transform/Composite. */
+  NvBufferTag_VIDEO_CONVERT   = 0xf01,
+} NvBufferTag;
+
+/**
+ * Defines color formats for NvBuffer.
+ */
+typedef enum
+{
+  /** BT.601 colorspace - YUV420 multi-planar. */
+  NvBufferColorFormat_YUV420,
+  /** BT.601 colorspace - YUV420 multi-planar. */
+  NvBufferColorFormat_YVU420,
+  /** BT.601 colorspace - YUV422 multi-planar. */
+  NvBufferColorFormat_YUV422,
+  /** BT.601 colorspace - YUV420 ER multi-planar. */
+  NvBufferColorFormat_YUV420_ER,
+  /** BT.601 colorspace - YVU420 ER multi-planar. */
+  NvBufferColorFormat_YVU420_ER,
+  /** BT.601 colorspace - Y/CbCr 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12,
+  /** BT.601 colorspace - Y/CbCr ER 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_ER,
+  /** BT.601 colorspace - Y/CbCr 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV21,
+  /** BT.601 colorspace - Y/CbCr ER 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV21_ER,
+  /** BT.601 colorspace - YUV 4:2:2 planar. */
+  NvBufferColorFormat_UYVY,
+  /** BT.601 colorspace - YUV ER 4:2:2 planar. */
+  NvBufferColorFormat_UYVY_ER,
+  /** BT.601 colorspace - YUV 4:2:2 planar. */
+  NvBufferColorFormat_VYUY,
+  /** BT.601 colorspace - YUV ER 4:2:2 planar. */
+  NvBufferColorFormat_VYUY_ER,
+  /** BT.601 colorspace - YUV 4:2:2 planar. */
+  NvBufferColorFormat_YUYV,
+  /** BT.601 colorspace - YUV ER 4:2:2 planar. */
+  NvBufferColorFormat_YUYV_ER,
+  /** BT.601 colorspace - YUV 4:2:2 planar. */
+  NvBufferColorFormat_YVYU,
+  /** BT.601 colorspace - YUV ER 4:2:2 planar. */
+  NvBufferColorFormat_YVYU_ER,
+  /** LegacyRGBA colorspace - BGRA-8-8-8-8 planar. */
+  NvBufferColorFormat_ABGR32,
+  /** LegacyRGBA colorspace - XRGB-8-8-8-8 planar. */
+  NvBufferColorFormat_XRGB32,
+  /** LegacyRGBA colorspace - ARGB-8-8-8-8 planar. */
+  NvBufferColorFormat_ARGB32,
+  /** BT.601 colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE,
+  /** BT.709 colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE_709,
+  /** BT.709_ER colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE_709_ER,
+  /** BT.2020 colorspace - Y/CbCr 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV12_10LE_2020,
+  /** BT.601 colorspace - Y/CrCb 4:2:0 10-bit multi-planar. */
+  NvBufferColorFormat_NV21_10LE,
+  /** BT.601 colorspace - Y/CbCr 4:2:0 12-bit multi-planar. */
+  NvBufferColorFormat_NV12_12LE,
+  /** BT.2020 colorspace - Y/CbCr 4:2:0 12-bit multi-planar. */
+  NvBufferColorFormat_NV12_12LE_2020,
+  /** BT.601 colorspace - Y/CrCb 4:2:0 12-bit multi-planar. */
+  NvBufferColorFormat_NV21_12LE,
+  /** BT.709 colorspace - YUV420 multi-planar. */
+  NvBufferColorFormat_YUV420_709,
+  /** BT.709 colorspace - YUV420 ER multi-planar. */
+  NvBufferColorFormat_YUV420_709_ER,
+  /** BT.709 colorspace - Y/CbCr 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_709,
+  /** BT.709 colorspace - Y/CbCr ER 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_709_ER,
+  /** BT.2020 colorspace - YUV420 multi-planar. */
+  NvBufferColorFormat_YUV420_2020,
+  /** BT.2020 colorspace - Y/CbCr 4:2:0 multi-planar. */
+  NvBufferColorFormat_NV12_2020,
+  /** Optical flow */
+  NvBufferColorFormat_SignedR16G16,
+  /** Optical flow SAD calculation Buffer format */
+  NvBufferColorFormat_A32,
+  /** BT.601 colorspace - YUV444 multi-planar. */
+  NvBufferColorFormat_YUV444,
+  /** 8-bit grayscale. */
+  NvBufferColorFormat_GRAY8,
+  /** BT.601 colorspace - Y/CbCr 4:2:2 multi-planar. */
+  NvBufferColorFormat_NV16,
+    /** BT.601 colorspace - Y/CbCr 4:2:2 10-bit semi-planar. */
+  NvBufferColorFormat_NV16_10LE,
+  /** BT.601 colorspace - Y/CbCr 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24,
+  /** BT.601_ER colorspace - Y/CbCr 4:2:2 multi-planar. */
+  NvBufferColorFormat_NV16_ER,
+  /** BT.601_ER colorspace - Y/CbCr 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24_ER,
+  /** BT.709 colorspace - Y/CbCr 4:2:2 multi-planar. */
+  NvBufferColorFormat_NV16_709,
+  /** BT.709 colorspace - Y/CbCr 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24_709,
+  /** BT.709_ER colorspace - Y/CbCr 4:2:2 multi-planar. */
+  NvBufferColorFormat_NV16_709_ER,
+  /** BT.709_ER colorspace - Y/CbCr 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24_709_ER,
+  /** BT.709 colorspace - Y/CbCr 10 bit 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24_10LE_709,
+  /** BT.709 ER colorspace - Y/CbCr 10 bit 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24_10LE_709_ER,
+  /** BT.2020 colorspace - Y/CbCr 10 bit 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24_10LE_2020,
+  /** BT.2020 colorspace - Y/CbCr 12 bit 4:4:4 multi-planar. */
+  NvBufferColorFormat_NV24_12LE_2020,
+  /** Non-linear RGB BT.709 colorspace - RGBA-10-10-10-2 planar. */
+  NvBufferColorFormat_RGBA_10_10_10_2_709,
+  /** Non-linear RGB BT.2020 colorspace - RGBA-10-10-10-2 planar. */
+  NvBufferColorFormat_RGBA_10_10_10_2_2020,
+  /** Non-linear RGB BT.709 colorspace - BGRA-10-10-10-2 planar. */
+  NvBufferColorFormat_BGRA_10_10_10_2_709,
+  /** Non-linear RGB BT.2020 colorspace - BGRA-10-10-10-2 planar. */
+  NvBufferColorFormat_BGRA_10_10_10_2_2020,
+  /** Invalid color format. */
+  NvBufferColorFormat_Invalid,
+} NvBufferColorFormat;
+
+/**
+ * Defines video flip methods.
+ */
+typedef enum
+{
+  /** Video flip none. */
+  NvBufferTransform_None,
+  /** Video flip rotate 90 degree counter-clockwise. */
+  NvBufferTransform_Rotate90,
+  /** Video flip rotate 180 degree. */
+  NvBufferTransform_Rotate180,
+  /** Video flip rotate 270 degree counter-clockwise. */
+  NvBufferTransform_Rotate270,
+  /** Video flip with respect to X-axis. */
+  NvBufferTransform_FlipX,
+  /** Video flip with respect to Y-axis. */
+  NvBufferTransform_FlipY,
+  /** Video flip transpose. */
+  NvBufferTransform_Transpose,
+  /** Video flip inverse transpode. */
+  NvBufferTransform_InvTranspose,
+} NvBufferTransform_Flip;
+
+/**
+ * Defines transform video filter types.
+ */
+typedef enum
+{
+  /** transform filter nearest. */
+  NvBufferTransform_Filter_Nearest,
+  /** transform filter bilinear. */
+  NvBufferTransform_Filter_Bilinear,
+  /** transform filter 5 tap. */
+  NvBufferTransform_Filter_5_Tap,
+  /** transform filter 10 tap. */
+  NvBufferTransform_Filter_10_Tap,
+  /** transform filter smart. */
+  NvBufferTransform_Filter_Smart,
+  /** transform filter nicest. */
+  NvBufferTransform_Filter_Nicest,
+} NvBufferTransform_Filter;
+
+/**
+ * Defines flags to indicate for valid transform.
+ */
+typedef enum {
+  /** transform flag to crop source rectangle. */
+  NVBUFFER_TRANSFORM_CROP_SRC   = 1,
+  /** transform flag to crop destination rectangle. */
+  NVBUFFER_TRANSFORM_CROP_DST   = 1 << 1,
+  /** transform flag to set filter type. */
+  NVBUFFER_TRANSFORM_FILTER     = 1 << 2,
+  /** transform flag to set flip method. */
+  NVBUFFER_TRANSFORM_FLIP       = 1 << 3,
+} NvBufferTransform_Flag;
+
+/**
+ * Defines flags that specify valid composition/blending operations.
+ */
+typedef enum {
+  /** flag to set for composition. */
+  NVBUFFER_COMPOSITE  = 1,
+  /** flag to set for blending. */
+  NVBUFFER_BLEND      = 1 << 1,
+} NvBufferComposite_Flag;
+
+/**
+ * Holds parameters for buffer sync point object.
+ * sync object params is simply a data structure containing [sync point ID,value] pair.
+ * This can be used by clients to describe an event that might want to wait for.
+ */
+typedef struct _NvBufferSyncObjParams
+{
+  uint32_t syncpointID;
+  uint32_t value;
+}NvBufferSyncObjParams;
+
+/**
+ * buffer sync point object.
+ */
+typedef struct _NvBufferSyncObjRec
+{
+  NvBufferSyncObjParams insyncobj[NVBUF_MAX_SYNCOBJ_PARAMS];
+  uint32_t num_insyncobj;
+  NvBufferSyncObjParams outsyncobj;
+  uint32_t use_outsyncobj;
+}NvBufferSyncObj;
+
+/**
+ * Holds composition background r,g,b colors.
+ */
+typedef struct
+{
+  /** background color value for r. */
+  float r;
+  /** background color value for g. */
+  float g;
+  /** background color value for b. */
+  float b;
+}NvBufferCompositeBackground;
+
+/**
+ * Holds coordinates for a rectangle.
+ */
+typedef struct
+{
+  /** rectangle top. */
+  uint32_t top;
+  /** rectangle left. */
+  uint32_t left;
+  /** rectangle width. */
+  uint32_t width;
+  /** rectangle height. */
+  uint32_t height;
+}NvBufferRect;
+
+/**
+ * Holds an opaque NvBuffer session type required for parallel buffer
+ * tranformations and compositions. Operations using a single session are
+ * scheduled sequentially, after the previous operation finishes. Operations for
+ * multiple sessions are scheduled in parallel.
+ */
+typedef struct _NvBufferSession * NvBufferSession;
+
+/**
+ * Holds Chroma Subsampling parameters.
+ */
+typedef struct _NvBufferChromaSubSamplingParams
+{
+  /** location settings */
+  uint8_t chromaLocHoriz;
+  uint8_t chromaLocVert;
+}NvBufferChromaSubsamplingParams;
+
+#define NVBUF_CHROMA_SUBSAMPLING_PARAMS_DEFAULT \
+  { \
+    NVBUF_CHROMA_SUBSAMPLING_HORIZ_DEFAULT, \
+    NVBUF_CHROMA_SUBSAMPLING_VERT_DEFAULT \
+  }
+
+/**
+ * Holds the input parameters for hardware buffer creation.
+ */
+typedef struct _NvBufferCreateParams
+{
+  /** width of the buffer. */
+  int32_t width;
+  /** height of the buffer. */
+  int32_t height;
+  /** payload type of the buffer. */
+  NvBufferPayloadType payloadType;
+  /** size of the memory.(Applicale for NvBufferPayload_MemHandle) */
+  int32_t memsize;
+  /** layout of the buffer. */
+  NvBufferLayout layout;
+  /** colorformat of the buffer. */
+  NvBufferColorFormat colorFormat;
+  /** tag to associate with the buffer. */
+  NvBufferTag nvbuf_tag;
+}NvBufferCreateParams;
+
+/**
+ * Holds parameters for a hardware buffer.
+ */
+typedef struct _NvBufferParams
+{
+  /** Holds the DMABUF FD of the hardware buffer. */
+  uint32_t dmabuf_fd;
+  /** pointer to hardware buffer memory. */
+  void *nv_buffer;
+  /** payload type of the buffer. */
+  NvBufferPayloadType payloadType;
+  /** size of the memory.(Applicale for NvBufferPayload_MemHandle) */
+  int32_t memsize;
+  /** size of hardware buffer. */
+  uint32_t nv_buffer_size;
+  /** video format type of hardware buffer. */
+  NvBufferColorFormat pixel_format;
+  /** number of planes of hardware buffer. */
+  uint32_t num_planes;
+  /** width of each planes of hardware buffer. */
+  uint32_t width[MAX_NUM_PLANES];
+  /** height of each planes of hardware buffer. */
+  uint32_t height[MAX_NUM_PLANES];
+  /** pitch of each planes of hardware buffer. */
+  uint32_t pitch[MAX_NUM_PLANES];
+  /** memory offset values of each video planes of hardware buffer. */
+  uint32_t offset[MAX_NUM_PLANES];
+  /** size of each vodeo planes of hardware buffer. */
+  uint32_t psize[MAX_NUM_PLANES];
+  /** layout type of each planes of hardware buffer. */
+  uint32_t layout[MAX_NUM_PLANES];
+}NvBufferParams;
+
+/**
+ * Holds extended parameters for a hardware buffer.
+ */
+typedef struct _NvBufferParamsEx
+{
+  /** nvbuffer basic parameters. */
+  NvBufferParams params;
+  /** offset in bytes from the start of the buffer to the first valid byte.
+      (Applicale for NvBufferPayload_MemHandle) */
+  int32_t startofvaliddata;
+  /** size of the valid data from the first to the last valid byte.
+      (Applicale for NvBufferPayload_MemHandle) */
+  int32_t sizeofvaliddatainbytes;
+  /** display scan format - progressive/interlaced. */
+  NvBufferDisplayScanFormat scanformat[MAX_NUM_PLANES];
+  /** offset of the second field for interlaced buffer. */
+  uint32_t secondfieldoffset[MAX_NUM_PLANES];
+  /** block height of the planes for blockLinear layout hardware buffer. */
+  uint32_t blockheightlog2[MAX_NUM_PLANES];
+  /** physical address of allocated planes. */
+  uint32_t physicaladdress[MAX_NUM_PLANES];
+  /** flags associated with planes */
+  uint64_t flags[MAX_NUM_PLANES];
+  /** metadata associated with the hardware buffer. */
+  void *payloadmetaInfo;
+  /** chroma subsampling parameters */
+  NvBufferChromaSubsamplingParams chromaSubsampling;
+  /** get buffer vpr information. */
+  bool is_protected;
+  /** buffer sync point object parameters */
+  NvBufferSyncObj syncobj;
+  /** reserved field. */
+  void *reserved;
+}NvBufferParamsEx;
+
+/**
+ * Holds parameters related to compositing/blending.
+ */
+typedef struct _NvBufferCompositeParams
+{
+  /** flag to indicate which of the composition/blending parameters are valid. */
+  uint32_t composite_flag;
+  /** number of the input buffers to be composited. */
+  uint32_t input_buf_count;
+  /** alpha values of input buffers for the blending. */
+  float dst_comp_rect_alpha[MAX_COMPOSITE_FRAME];
+  /** source rectangle coordinates of input buffers for composition. */
+  NvBufferRect src_comp_rect[MAX_COMPOSITE_FRAME];
+  /** destination rectangle coordinates of input buffers for composition. */
+  NvBufferRect dst_comp_rect[MAX_COMPOSITE_FRAME];
+  /** background color values for composition. */
+  NvBufferCompositeBackground composite_bgcolor;
+  /** NvBufferSession to be used for composition. If NULL, the default session
+   * is used. */
+  NvBufferSession session;
+}NvBufferCompositeParams;
+
+/**
+ * Holds parameters for buffer transform functions.
+ */
+typedef struct _NvBufferTransformParams
+{
+  /** flag to indicate which of the transform parameters are valid. */
+  uint32_t transform_flag;
+  /** flip method. */
+  NvBufferTransform_Flip transform_flip;
+  /** transform filter. */
+  NvBufferTransform_Filter transform_filter;
+  /** source rectangle coordinates for crop opeartion. */
+  NvBufferRect src_rect;
+  /** destination rectangle coordinates for crop opeartion. */
+  NvBufferRect dst_rect;
+  /** NvBufferSession to be used for transform. If NULL, the default session
+   * is used. */
+  NvBufferSession session;
+}NvBufferTransformParams;
+
+
+/**
+* This method can be used to wait on sync point ID.
+*
+* @param[in] syncobj_params  sync point object parameters.
+* @param[in] timeout         sync point wait timeout value.
+*
+* @returns 0 for success, -1 for failure
+*/
+int NvBufferSyncObjWait (NvBufferSyncObjParams *syncobj_params, unsigned int timeout);
+
+/**
+* This method can be used to get HW Buffer struct size.
+*
+* @returns HW Buffer struct size.
+*/
+int NvBufferGetSize (void);
+
+/**
+* Creates an instance of EGLImage from a DMABUF FD.
+*
+* @param[in] display    An EGLDisplay object used during the creation
+*                       of the EGLImage. If NULL, nvbuf_utils() uses
+*                       its own instance of EGLDisplay.
+* @param[in] dmabuf_fd  DMABUF FD of the buffer from which the EGLImage
+*                       is to be created.
+*
+* @returns `EGLImageKHR` for success, `NULL` for failure
+*/
+EGLImageKHR NvEGLImageFromFd (EGLDisplay display, int dmabuf_fd);
+
+/**
+* Destroys an EGLImage object.
+*
+* @param[in] display    An EGLDisplay object used to destroy the EGLImage.
+*                       If NULL, nvbuf_utils() uses its own instance of
+*                       EGLDisplay.
+* @param[in] eglImage   The EGLImageKHR object to be destroyed.
+*
+* @returns 0 for success, -1 for failure
+*/
+int NvDestroyEGLImage (EGLDisplay display, EGLImageKHR eglImage);
+
+/**
+ * Allocates a HW buffer (deprecated).
+ *
+ * @deprecated Use NvBufferCreateEx() instead.
+ * @param[out] dmabuf_fd    Returns the DMABUF FD of the hardware buffer.
+ * @param[in]  width        Buffer width, in bytes.
+ * @param[in]  height       Buffer height, in bytes.
+ * @param[in]  layout       Layout of the buffer.
+ * @param[in]  colorFormat  Color format of the buffer.
+ *
+ * @return 0 if successful, or -1 otherwise.
+ */
+int NvBufferCreate (int *dmabuf_fd, int width, int height,
+    NvBufferLayout layout, NvBufferColorFormat colorFormat);
+
+/**
+ * Allocates a hardware buffer.
+ *
+ * @param[out] dmabuf_fd    Returns the DMABUF FD of the hardware buffer.
+ * @param[in]  input_params Input parameters for hardware buffer creation.
+ *
+ * @returns 0 for success, -1 for failure
+ */
+int NvBufferCreateEx (int *dmabuf_fd, NvBufferCreateParams *input_params);
+
+/**
+ * Allocates a hardware buffer for interlace scan format.
+ *
+ * @param[out] dmabuf_fd    Returns the DMABUF FD of the hardware buffer.
+ * @param[in]  input_params Input parameters for hardware buffer creation.
+ *
+ * @returns 0 for success, -1 for failure
+ */
+int NvBufferCreateInterlace (int *dmabuf_fd, NvBufferCreateParams *input_params);
+
+
+/**
+ * Allocates a hardware buffer with a given chroma subsampling location.
+ *
+ * @param[in] dmabuf_fd         DMABUF FD of the buffer.
+ * @param[in] input_params      Input parameters for hardware buffer creation.
+ * @param[in] chromaSubsampling Chroma location parameters.
+ *
+ * @returns 0 for success, -1 for failure
+ */
+int NvBufferCreateWithChromaLoc (int *dmabuf_fd, NvBufferCreateParams *input_params, NvBufferChromaSubsamplingParams *chromaSubsampling);
+
+/**
+ * Gets buffer parameters.
+ * @param[in] dmabuf_fd `DMABUF FD` of buffer.
+ * @param[out] params A pointer to the structure to fill with parameters.
+ *
+ * @returns 0 for success, -1 for failure.
+ */
+int NvBufferGetParams (int dmabuf_fd, NvBufferParams *params);
+
+/**
+ * Gets buffer extended parameters.
+ * @param[in] dmabuf_fd `DMABUF FD` of buffer.
+ * @param[out] exparams A pointer to the structure to fill with extended parameters.
+ *
+ * @returns 0 for success, -1 for failure.
+ */
+int NvBufferGetParamsEx (int dmabuf_fd, NvBufferParamsEx *exparams);
+
+/**
+* Destroys a HW buffer.
+* @param[in] dmabuf_fd Specifies the `dmabuf_fd` `hw_buffer` to destroy.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferDestroy (int dmabuf_fd);
+
+/**
+* Extracts the `dmabuf_fd` from the hardware buffer.
+* @param[in] nvbuf Specifies the `hw_buffer`.
+* @param[out] dmabuf_fd Returns DMABUF FD of `hw_buffer`.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int ExtractFdFromNvBuffer (void *nvbuf, int *dmabuf_fd);
+
+/**
+* Releases the `dmabuf_fd` buffer.
+* @see ExtractfdFromNvBuffer()
+* @param[in] dmabuf_fd Specifies the `dmabuf_fd` to release.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvReleaseFd (int dmabuf_fd);
+
+/**
+* Syncs the HW memory cache for the CPU.
+*
+* \sa NvBufferMemMap for the purpose of the function
+*
+* @param[in] dmabuf_fd DMABUF FD of buffer.
+* @param[in] plane video frame plane.
+* @param[in] pVirtAddr Virtual Address pointer of the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+
+*/
+int NvBufferMemSyncForCpu (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+
+/**
+* Syncs the hardware memory cache for the device.
+*
+* \sa NvBufferMemMap for the purpose of the function
+*
+* @param[in] dmabuf_fd DMABUF FD of buffer.
+* @param[in] plane video frame plane.
+* @param[in] pVirtAddr Virtual Address pointer of the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferMemSyncForDevice (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+
+/**
+* Gets the memory-mapped virtual address of the plane.
+*
+* The client must call NvBufferMemSyncForCpu() with the virtual address returned
+* by this function before accessing the mapped memory in CPU.
+*
+* After memory mapping is complete, mapped memory modification
+* must be coordinated between the CPU and hardware device as
+* follows:
+* - CPU: If the CPU modifies any mapped memory, the client must call
+*   NvBufferMemSyncForDevice() before any hardware device accesses the memory.
+* - Hardware device: If the mapped memory is modified by any hardware device,
+*   the client must call NvBufferMemSyncForCpu() before CPU accesses the memory.
+*
+* @param[in] dmabuf_fd DMABUF FD of buffer.
+* @param[in] plane video frame plane.(Applies to @ref NvBufferPayload_SurfArray.)
+* @param[in] memflag NvBuffer memory flag.
+* @param[out] pVirtAddr Virtual Address pointer of the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferMemMap (int dmabuf_fd, unsigned int plane, NvBufferMemFlags memflag, void **pVirtAddr);
+
+/**
+* Unmaps the mapped virtual address of the plane.
+*
+* If the following conditions are both true, the client must call
+* NvBufferMemSyncForDevice() before unmapping the memory:
+* - Mapped memory was modified by the CPU.
+* - Mapped memory will be accessed by a hardware device.
+*
+* @param[in] dmabuf_fd  DMABUF FD of the buffer.
+* @param[in] plane      Video frame plane. Applies to
+*                       @ref NvBufferPayload_SurfArray.
+* @param[in] pVirtAddr  Virtual address pointer to the memory-mapped plane.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBufferMemUnMap (int dmabuf_fd, unsigned int plane, void **pVirtAddr);
+
+/**
+* Copies the NvBuffer plane contents to a raw buffer plane.
+* @param[in] dmabuf_fd DMABUF FD of NvBuffer.
+* @param[in] plane video frame plane.
+* @param[in] out_width aligned width of the raw data plane.
+* @param[in] out_height aligned height of the raw data plane.
+* @param[in] ptr pointer to the output raw plane data.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int NvBuffer2Raw (int dmabuf_fd, unsigned int plane, unsigned int out_width, unsigned int out_height, unsigned char *ptr);
+
+/**
+* Copies raw buffer plane contents to an NvBuffer plane.
+* @param[in] ptr pointer to the input raw plane data.
+* @param[in] plane video frame plane.
+* @param[in] in_width aligned width of the raw data plane.
+* @param[in] in_height aligned height of the raw data plane.
+* @param[in] dmabuf_fd DMABUF FD of NvBuffer.
+*
+* @returns 0 for success, -1 for failure.
+*/
+int Raw2NvBuffer (unsigned char *ptr, unsigned int plane, unsigned int in_width, unsigned int in_height, int dmabuf_fd);
+
+/**
+* Creates a new NvBufferSession for parallel scheduling of
+* buffer transformations and compositions.
+*
+* @returns A session pointer, NULL for failure.
+*/
+NvBufferSession NvBufferSessionCreate(void);
+
+/**
+* Destroys an existing \ref NvBufferSession.
+* @param[in] session    An existing NvBufferSession.
+*/
+void NvBufferSessionDestroy(NvBufferSession session);
+
+/**
+ * Transforms one DMA buffer to another DMA buffer.
+ * This function can support transforms for copying, scaling, fliping, rotating, and cropping.
+ * @param[in] src_dmabuf_fd DMABUF FD of source buffer
+ * @param[in] dst_dmabuf_fd DMABUF FD of destination buffer
+ * @param[in] transform_params transform parameters
+ *
+ * @return 0 for sucess, -1 for failure.
+ */
+int NvBufferTransform (int src_dmabuf_fd, int dst_dmabuf_fd, NvBufferTransformParams *transform_params);
+
+/**
+ * Transforms one DMA buffer to another DMA buffer asyncroniously (non-blocking).
+ * This function can support transforms for copying, scaling, fliping, rotating, and cropping.
+ * @param[in] src_dmabuf_fd DMABUF FD of source buffer
+ * @param[in] dst_dmabuf_fd DMABUF FD of destination buffer
+ * @param[in] transform_params transform parameters
+ * @param[in] syncobj nvbuffer sync point object
+ *
+ * @return 0 for sucess, -1 for failure.
+ */
+int NvBufferTransformAsync (int src_dmabuf_fd, int dst_dmabuf_fd, NvBufferTransformParams *transform_params, NvBufferSyncObj *syncobj);
+
+
+/**
+ * \brief Composites multiple input DMA buffers to one output DMA buffer.
+ *
+ * This function can composite multiple input frames to one output.
+ *
+ * @param[in] src_dmabuf_fds    An array of DMABUF FDs of source buffers.
+ *                              These buffers are composited together. Output
+ *                              is copied to the output buffer referenced by
+ *                              @a dst_dmabuf_fd.
+ * @param[in] dst_dmabuf_fd     DMABUF FD of the compositing destination buffer.
+ * @param[in] composite_params  Compositing parameters.
+ */
+int NvBufferComposite (int *src_dmabuf_fds, int dst_dmabuf_fd, NvBufferCompositeParams *composite_params);
+
+#ifdef __cplusplus
+}
+#endif
+
+/** @} */
+
+#endif
diff --git a/media/gpu/nvbuf/nvbufutils_stub_header.fragment b/media/gpu/nvbuf/nvbufutils_stub_header.fragment
new file mode 100644
index 0000000..6dc4efe
--- /dev/null
+++ b/media/gpu/nvbuf/nvbufutils_stub_header.fragment
@@ -0,0 +1,8 @@
+// The extra include header needed in the generated stub file for defining
+// various Pulse types.
+
+extern "C" {
+
+#include "media/gpu/nvbuf/nvbuf_utils.h"
+
+}
diff --git a/media/gpu/nvbuf/v4l2_nv_extensions.h b/media/gpu/nvbuf/v4l2_nv_extensions.h
new file mode 100644
index 0000000..d4eaad11
--- /dev/null
+++ b/media/gpu/nvbuf/v4l2_nv_extensions.h
@@ -0,0 +1,2341 @@
+/*
+ * Copyright (c) 2016-2020, NVIDIA CORPORATION.  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *  3. The names of its contributors may not be used to endorse or promote
+ *     products derived from this software without specific prior written
+ *     permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* This file contains amendments to the V4L2 headers made after the
+ * supported kernel version and NVIDIA extensions.
+ */
+
+#ifndef __V4L2_NV_EXTENSIONS_H__
+#define __V4L2_NV_EXTENSIONS_H__
+
+/**
+ * @file
+ * <b>NVIDIA V4L2 API Extensions</b>
+ *
+ * @b Description: This file declares NVIDIA V4L2 extensions,
+ * controls and structures.
+ */
+
+/**
+ *
+ * @defgroup ee_extensions_group V4L2 NV Extensions API
+ *
+ * This file declares NVIDIA V4L2 extensions, controls, and structures.
+ *
+ */
+/**
+ * Defines V4L2 pixel format for DIVX.
+ */
+#define V4L2_PIX_FMT_DIVX4     v4l2_fourcc('D', 'V', 'X', '4')
+
+#define V4L2_PIX_FMT_DIVX5     v4l2_fourcc('D', 'V', 'X', '5')
+/**
+ * Defines V4L2 pixel format for H.265.
+ */
+#define V4L2_PIX_FMT_H265     v4l2_fourcc('H', '2', '6', '5')
+
+/**
+ * Defines the V4L2 pixel format for VP9.
+ */
+#define V4L2_PIX_FMT_VP9      v4l2_fourcc('V', 'P', '9', '0')
+
+/**
+ * Defines the V4L2 pixel format for representing single plane 10-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P010    v4l2_fourcc('P', '0', '1', '0') /* Y/CbCr 4:2:0, 10 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing semi-planar 10-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P010M   v4l2_fourcc('P', 'M', '1', '0') /* Y/CbCr 4:2:0, 10 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing single plane 12-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P012    v4l2_fourcc('P', '0', '1', '2') /* Y/CbCr 4:2:0, 12 bits per channel */
+
+/**
+ * Defines the V4L2 pixel format for representing semi-planar 12-bit Y/CbCr 4:2:0 decoder data.
+ */
+#define V4L2_PIX_FMT_P012M   v4l2_fourcc('P', 'M', '1', '2') /* Y/CbCr 4:2:0, 12 bits per channel */
+
+
+/** @cond UNUSED */
+/* >> The declarations from here to the next endcond statement are not
+ * >> currently implemented. DO NOT USE. */
+
+#define V4L2_PIX_FMT_YUV422RM v4l2_fourcc('4', '2', 'R', 'M')
+
+
+#define V4L2_PIX_FMT_H264_SLICE v4l2_fourcc('S', '2', '6', '4') /** H264 parsed slices. */
+#define V4L2_PIX_FMT_VP8_FRAME v4l2_fourcc('V', 'P', '8', 'F') /** VP8 parsed frames. */
+
+#define V4L2_CTRL_FLAG_CAN_STORE    0x0200
+
+/** @endcond */
+
+/**
+ * Defines the V4L2 event type for decoder resolution event change.
+ */
+#define V4L2_EVENT_RESOLUTION_CHANGE        5
+
+/** @cond UNUSED */
+/* >> The declarations from here to the next endcond statement are not
+ * >> currently implemented. DO NOT USE. */
+
+/*---------------Below are changes from the v4l2-controls.h----------------------*/
+
+#define V4L2_CID_MPEG_VIDEO_H264_SPS        (V4L2_CID_MPEG_BASE+383)
+#define V4L2_CID_MPEG_VIDEO_H264_PPS        (V4L2_CID_MPEG_BASE+384)
+#define V4L2_CID_MPEG_VIDEO_H264_SCALING_MATRIX (V4L2_CID_MPEG_BASE+385)
+#define V4L2_CID_MPEG_VIDEO_H264_SLICE_PARAM    (V4L2_CID_MPEG_BASE+386)
+#define V4L2_CID_MPEG_VIDEO_H264_DECODE_PARAM   (V4L2_CID_MPEG_BASE+387)
+
+#define V4L2_CID_MPEG_VIDEO_VP8_FRAME_HDR       (V4L2_CID_MPEG_BASE+512)
+
+/** @endcond */
+
+/**
+ * Defines the control ID to set the H.265 encoder profile.
+ *
+ * A v4l2_mpeg_video_h265_profile must be passed.
+ */
+#define V4L2_CID_MPEG_VIDEO_H265_PROFILE        (V4L2_CID_MPEG_BASE+513)
+
+/**
+ * Defines the possible profiles for H.265 encoder.
+ */
+enum v4l2_mpeg_video_h265_profile {
+    /** H.265 Main profile. */
+    V4L2_MPEG_VIDEO_H265_PROFILE_MAIN = 0,
+    /** H.265 Main10 profile. */
+    V4L2_MPEG_VIDEO_H265_PROFILE_MAIN10 = 1,
+    /** H.265 MainStillPicture profile. */
+    V4L2_MPEG_VIDEO_H265_PROFILE_MAINSTILLPICTURE = 2,
+};
+
+/**
+ * Defines the control ID to set the encoder IDR frame interval.
+ * Must be used with \c VIDIOC_S_EXT_CTRLS IOCTL.
+ */
+#define V4L2_CID_MPEG_VIDEO_IDR_INTERVAL        (V4L2_CID_MPEG_BASE+514)
+
+/** @cond UNUSED */
+/* >> The declarations from here to the next endcond statement are not
+ * >> currently implemented. DO NOT USE. */
+
+/* Complex controls */
+
+#define V4L2_H264_SPS_CONSTRAINT_SET0_FLAG          0x01
+#define V4L2_H264_SPS_CONSTRAINT_SET1_FLAG          0x02
+#define V4L2_H264_SPS_CONSTRAINT_SET2_FLAG          0x04
+#define V4L2_H264_SPS_CONSTRAINT_SET3_FLAG          0x08
+#define V4L2_H264_SPS_CONSTRAINT_SET4_FLAG          0x10
+#define V4L2_H264_SPS_CONSTRAINT_SET5_FLAG          0x20
+
+#define V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE        0x01
+#define V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS  0x02
+#define V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO      0x04
+#define V4L2_H264_SPS_FLAG_GAPS_IN_FRAME_NUM_VALUE_ALLOWED  0x08
+#define V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY           0x10
+#define V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD      0x20
+#define V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE         0x40
+struct v4l2_ctrl_h264_sps {
+    __u8 profile_idc;
+    __u8 constraint_set_flags;
+    __u8 level_idc;
+    __u8 seq_parameter_set_id;
+    __u8 chroma_format_idc;
+    __u8 bit_depth_luma_minus8;
+    __u8 bit_depth_chroma_minus8;
+    __u8 log2_max_frame_num_minus4;
+    __u8 pic_order_cnt_type;
+    __u8 log2_max_pic_order_cnt_lsb_minus4;
+    __s32 offset_for_non_ref_pic;
+    __s32 offset_for_top_to_bottom_field;
+    __u8 num_ref_frames_in_pic_order_cnt_cycle;
+    __s32 offset_for_ref_frame[255];
+    __u8 max_num_ref_frames;
+    __u16 pic_width_in_mbs_minus1;
+    __u16 pic_height_in_map_units_minus1;
+    __u8 flags;
+};
+
+#define V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE              0x0001
+#define V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT  0x0002
+#define V4L2_H264_PPS_FLAG_WEIGHTED_PRED                0x0004
+#define V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT        0x0008
+#define V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED           0x0010
+#define V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT            0x0020
+#define V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE               0x0040
+#define V4L2_H264_PPS_FLAG_PIC_SCALING_MATRIX_PRESENT           0x0080
+struct v4l2_ctrl_h264_pps {
+    __u8 pic_parameter_set_id;
+    __u8 seq_parameter_set_id;
+    __u8 num_slice_groups_minus1;
+    __u8 num_ref_idx_l0_default_active_minus1;
+    __u8 num_ref_idx_l1_default_active_minus1;
+    __u8 weighted_bipred_idc;
+    __s8 pic_init_qp_minus26;
+    __s8 pic_init_qs_minus26;
+    __s8 chroma_qp_index_offset;
+    __s8 second_chroma_qp_index_offset;
+    __u8 flags;
+};
+
+struct v4l2_ctrl_h264_scaling_matrix {
+    __u8 scaling_list_4x4[6][16];
+    __u8 scaling_list_8x8[6][64];
+};
+
+struct v4l2_h264_weight_factors {
+    __s8 luma_weight[32];
+    __s8 luma_offset[32];
+    __s8 chroma_weight[32][2];
+    __s8 chroma_offset[32][2];
+};
+
+struct v4l2_h264_pred_weight_table {
+    __u8 luma_log2_weight_denom;
+    __u8 chroma_log2_weight_denom;
+    struct v4l2_h264_weight_factors weight_factors[2];
+};
+
+#define V4L2_SLICE_FLAG_FIELD_PIC       0x01
+#define V4L2_SLICE_FLAG_BOTTOM_FIELD        0x02
+#define V4L2_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED  0x04
+#define V4L2_SLICE_FLAG_SP_FOR_SWITCH       0x08
+struct v4l2_ctrl_h264_slice_param {
+    /** Holds the size in bytes, including the header. */
+    __u32 size;
+    /** Holds the offset in bits to slice_data() from the beginning of this slice. */
+    __u32 header_bit_size;
+
+    __u16 first_mb_in_slice;
+    __u8 slice_type;
+    __u8 pic_parameter_set_id;
+    __u8 colour_plane_id;
+    __u16 frame_num;
+    __u16 idr_pic_id;
+    __u16 pic_order_cnt_lsb;
+    __s32 delta_pic_order_cnt_bottom;
+    __s32 delta_pic_order_cnt0;
+    __s32 delta_pic_order_cnt1;
+    __u8 redundant_pic_cnt;
+
+    struct v4l2_h264_pred_weight_table pred_weight_table;
+    /* Size in bits of dec_ref_pic_marking() syntax element. */
+    __u32 dec_ref_pic_marking_bit_size;
+    /* Size in bits of pic order count syntax. */
+    __u32 pic_order_cnt_bit_size;
+
+    __u8 cabac_init_idc;
+    __s8 slice_qp_delta;
+    __s8 slice_qs_delta;
+    __u8 disable_deblocking_filter_idc;
+    __s8 slice_alpha_c0_offset_div2;
+    __s8 slice_beta_offset_div2;
+    __u32 slice_group_change_cycle;
+
+    __u8 num_ref_idx_l0_active_minus1;
+    __u8 num_ref_idx_l1_active_minus1;
+    /*  Entries on each list are indices
+     *  into v4l2_ctrl_h264_decode_param.dpb[]. */
+    __u8 ref_pic_list0[32];
+    __u8 ref_pic_list1[32];
+
+    __u8 flags;
+};
+
+/** Defines whether the v4l2_h264_dpb_entry structure is used.
+If not set, this entry is unused for reference. */
+#define V4L2_H264_DPB_ENTRY_FLAG_ACTIVE     0x01
+#define V4L2_H264_DPB_ENTRY_FLAG_LONG_TERM  0x02
+struct v4l2_h264_dpb_entry {
+    __u32 buf_index; /**< v4l2_buffer index. */
+    __u16 frame_num;
+    __u16 pic_num;
+    /** @note `v4l2_buffer.field` specifies this field. */
+    __s32 top_field_order_cnt;
+    __s32 bottom_field_order_cnt;
+    __u8 flags; /* V4L2_H264_DPB_ENTRY_FLAG_* */
+};
+
+struct v4l2_ctrl_h264_decode_param {
+    __u32 num_slices;
+    __u8 idr_pic_flag;
+    __u8 nal_ref_idc;
+    __s32 top_field_order_cnt;
+    __s32 bottom_field_order_cnt;
+    __u8 ref_pic_list_p0[32];
+    __u8 ref_pic_list_b0[32];
+    __u8 ref_pic_list_b1[32];
+    struct v4l2_h264_dpb_entry dpb[16];
+};
+
+#define V4L2_VP8_SEGMNT_HDR_FLAG_ENABLED              0x01
+#define V4L2_VP8_SEGMNT_HDR_FLAG_UPDATE_MAP           0x02
+#define V4L2_VP8_SEGMNT_HDR_FLAG_UPDATE_FEATURE_DATA  0x04
+struct v4l2_vp8_sgmnt_hdr {
+    __u8 segment_feature_mode;
+
+    __s8 quant_update[4];
+    __s8 lf_update[4];
+    __u8 segment_probs[3];
+
+    __u8 flags;
+};
+
+#define V4L2_VP8_LF_HDR_ADJ_ENABLE  0x01
+#define V4L2_VP8_LF_HDR_DELTA_UPDATE    0x02
+struct v4l2_vp8_loopfilter_hdr {
+    __u8 type;
+    __u8 level;
+    __u8 sharpness_level;
+    __s8 ref_frm_delta_magnitude[4];
+    __s8 mb_mode_delta_magnitude[4];
+
+    __u8 flags;
+};
+
+struct v4l2_vp8_quantization_hdr {
+    __u8 y_ac_qi;
+    __s8 y_dc_delta;
+    __s8 y2_dc_delta;
+    __s8 y2_ac_delta;
+    __s8 uv_dc_delta;
+    __s8 uv_ac_delta;
+    __u16 dequant_factors[4][3][2];
+};
+
+struct v4l2_vp8_entropy_hdr {
+    __u8 coeff_probs[4][8][3][11];
+    __u8 y_mode_probs[4];
+    __u8 uv_mode_probs[3];
+    __u8 mv_probs[2][19];
+};
+
+#define V4L2_VP8_FRAME_HDR_FLAG_EXPERIMENTAL        0x01
+#define V4L2_VP8_FRAME_HDR_FLAG_SHOW_FRAME      0x02
+#define V4L2_VP8_FRAME_HDR_FLAG_MB_NO_SKIP_COEFF    0x04
+struct v4l2_ctrl_vp8_frame_hdr {
+    /** 0: keyframe, 1: not a keyframe. */
+    __u8 key_frame;
+    __u8 version;
+
+    /** Populated also if not a key frame. */
+    __u16 width;
+    __u8 horizontal_scale;
+    __u16 height;
+    __u8 vertical_scale;
+
+    struct v4l2_vp8_sgmnt_hdr sgmnt_hdr;
+    struct v4l2_vp8_loopfilter_hdr lf_hdr;
+    struct v4l2_vp8_quantization_hdr quant_hdr;
+    struct v4l2_vp8_entropy_hdr entropy_hdr;
+
+    __u8 sign_bias_golden;
+    __u8 sign_bias_alternate;
+
+    __u8 prob_skip_false;
+    __u8 prob_intra;
+    __u8 prob_last;
+    __u8 prob_gf;
+
+    __u32 first_part_size;
+    /**
+     * Holds the offset in bits of the MB data in the first partition,
+     * i.e. bit offset starting from first_part_offset.
+     */
+    __u32 first_part_offset;
+    __u32 macroblock_bit_offset;
+
+    __u8 num_dct_parts;
+    __u32 dct_part_sizes[8];
+
+    __u8 bool_dec_range;
+    __u8 bool_dec_value;
+    __u8 bool_dec_count;
+
+    /** Holds the v4l2_buffer index of the last reference frame. */
+    __u32 last_frame;
+     /** Holds the v4l2_buffer index of the golden reference frame. */
+   __u32 golden_frame;
+    /** Holds the v4l2_buffer index of the alt reference frame. */
+    __u32 alt_frame;
+
+    __u8 flags;
+};
+
+/** @endcond */
+
+/*---------------Add below NVIDIA specific extensions ----------------------*/
+
+/**
+ * @defgroup V4L2Dec V4L2 Video Decoder
+ *
+ * @brief NVIDIA V4L2 Video Decoder Description and Extensions
+ *
+ * The video decoder device node is
+ *
+ *     /dev/nvhost-nvdec
+ *
+ * ### Supported Pixel Formats
+ * OUTPUT PLANE       | CAPTURE PLANE
+ * :----------------: | :----------------:
+ * V4L2_PIX_FMT_H264  | V4L2_PIX_FMT_NV12M
+ * V4L2_PIX_FMT_H265  | V4L2_PIX_FMT_NV12M
+ *
+ * ### Supported Memory Types
+ * MEMORY               | OUTPUT PLANE | CAPTURE PLANE
+ * :------------------: | :----------: | :-----------:
+ * V4L2_MEMORY_MMAP     | Y            | Y
+ * V4L2_MEMORY_DMABUF   | N            | N
+ * V4L2_MEMORY_USERPTR  | N            | N
+ *
+ * ### Supported Controls
+ * - #V4L2_CID_MPEG_VIDEO_DISABLE_COMPLETE_FRAME_INPUT
+ * - #V4L2_CID_MPEG_VIDEO_DISABLE_DPB
+ * - #V4L2_CID_MPEG_VIDEO_ERROR_REPORTING
+ * - #V4L2_CID_MPEG_VIDEO_SKIP_FRAMES
+ * - V4L2_CID_MIN_BUFFERS_FOR_CAPTURE (Get the minimum buffers to be allocated on capture plane.
+ * Read only. Valid after #V4L2_EVENT_RESOLUTION_CHANGE)
+ * - #V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA
+ * - #V4L2_CID_MPEG_VIDEODEC_METADATA
+ * - #V4L2_CID_MPEG_VIDEO_BUF_API_TYPE
+ * - #V4L2_CID_MPEG_VIDEO_CUDA_MEM_TYPE
+ * - #V4L2_CID_MPEG_VIDEO_CUDA_GPU_ID
+ * - #V4L2_CID_MPEG_VIDEODEC_DROP_FRAME_INTERVAL
+ *
+ * ### Supported Events
+ * Event                         | Purpose
+ * ----------------------------- | :----------------------------:
+ * #V4L2_EVENT_RESOLUTION_CHANGE | Resolution of the stream has changed.
+ *
+ * ### Handling Resolution Change Events
+ * When the decoder generates a \c V4L2_EVENT_RESOLUTION_CHANGE event, the
+ * application calls \c STREAMOFF on the capture plane to tell the decoder to
+ * deallocate the current buffers by calling REQBUF with count zero, get
+ * the new capture plane format, and then proceed with setting up the buffers
+ * for the capture plane.
+ *
+ * In case of decoder, the buffer format might differ from the display resolution.
+ * The application must use \c VIDIOC_G_CROP to get the display resolution.
+ *
+ * ### EOS Handling
+ * The following sequence must be followed for sending EOS and recieving EOS
+ * from the decoder.
+ * -# Send EOS to decoder by queueing on the output plane a buffer with
+ * bytesused = 0 for the 0th plane (`v4l2_buffer.m.planes[0].bytesused = 0`).
+ * -# Dequeues buffers on the output plane until it gets a buffer with bytesused = 0
+ * for the 0th plane (`v4l2_buffer.m.planes[0].bytesused == 0`)
+ * -# Dequeues buffers on the capture plane until it gets a buffer with bytesused = 0
+ * for the 0th plane.
+ *
+ * ### Decoder Input Frame Metadata
+ * Decoder supports reporting stream header parsing error info as input frame metadata.
+ * See \c V4L2_CID_MPEG_VIDEO_ERROR_REPORTING, \c V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA
+ * and \c v4l2_ctrl_video_metadata for more information.
+ *
+ * ### Decoder Output Frame Metadata
+ * Decoder supports reporting frame related metadata, including error reports and
+ * DPB info. See \c V4L2_CID_MPEG_VIDEO_ERROR_REPORTING, \c V4L2_CID_MPEG_VIDEODEC_METADATA
+ * and \c v4l2_ctrl_video_metadata for more information.
+ *
+ * @note Currently, V4L2 plugins do not support odd resolution.
+ * @{
+ * @ingroup ee_extensions_group
+ */
+
+/**
+ * Defines the Control ID to indicate to the decoder that the input
+ * buffers do not contain complete buffers.
+ *
+ * @note This control must be set in case of frames containing multiple slices
+ * when the input buffers do not contain all the slices of the frame.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ */
+#define V4L2_CID_MPEG_VIDEO_DISABLE_COMPLETE_FRAME_INPUT (V4L2_CID_MPEG_BASE+515)
+
+/**
+ * Defines the Control ID to disable decoder DPB management.
+ *
+ * @note This only works for streams having a single reference frame.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_DISABLE_DPB (V4L2_CID_MPEG_BASE+516)
+
+/**
+ * Defines the Control ID to enable decoder error and metadata reporting.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_ERROR_REPORTING (V4L2_CID_MPEG_BASE+517)
+
+/**
+ * Defines the Control ID to set the skip frames property of the decoder.
+ *
+ * Decoder must be configured to skip certain types of frames. One
+ * \c v4l2_skip_frames_type must be passed.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ * This control ID is supported only for H264.
+ */
+#define V4L2_CID_MPEG_VIDEO_SKIP_FRAMES (V4L2_CID_MPEG_BASE+518)
+
+/**
+ * Defines the Control ID to get the decoder output metadata.
+ *
+ * @note Metadata reporting must be enabled using
+ * #V4L2_CID_MPEG_VIDEO_ERROR_REPORTING IOCTL for this.
+ *
+ * A pointer to a valid \c v4l2_ctrl_video_metadata structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the capture plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEODEC_METADATA (V4L2_CID_MPEG_BASE+519)
+
+/**
+ * Defines the Control ID to get the decoder input header error metadata.
+ *
+ * @note Metadata reporting must be enabled using
+ * #V4L2_CID_MPEG_VIDEO_ERROR_REPORTING IOCTL for this.
+ *
+ * A pointer to a valid \c v4l2_ctrl_video_metadata structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the output plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA (V4L2_CID_MPEG_BASE+520)
+
+/**
+ * Defines the Control ID to check if display data is present.
+ *
+ * This control returns true if HDR metadata is present in the stream.
+ *
+ */
+#define V4L2_CID_VIDEODEC_DISPLAYDATA_PRESENT (V4L2_CID_MPEG_BASE+521)
+
+/**
+ * Defines the Control ID to get display data if V4L2_CID_VIDEODEC_DISPLAYDATA_PRESENT returns true.
+ *
+ * This control returns display data such as display_primaries, white_point and
+ * display_parameter_luminance required for display module.
+ *
+ */
+#define V4L2_CID_VIDEODEC_HDR_MASTERING_DISPLAY_DATA (V4L2_CID_MPEG_BASE+522)
+
+/** @} */
+
+/**
+ * @defgroup V4L2Conv V4L2 Video Converter
+ *
+ * @brief NVIDIA V4L2 Video Converter Description and Extensions
+ *
+ * Use the video converter for color space conversion, scaling, and
+ * conversion between hardware buffer memory (\c V4L2_MEMORY_MMAP/\c
+ * V4L2_MEMORY_DMABUF), software buffer memory (\c V4L2_MEMORY_USERPTR), and
+ * other operations such as cropping, flipping/rotating, and
+ * temporal noise reduction (TNR).
+ * The video converter device node is \c "/dev/nvhost-vic".
+ *
+ * ### Supported Pixelformats
+ *  PIXEL FORMAT           | PIXEL FORMAT
+ * :---------------------: | :--------------:
+ * V4L2_PIX_FMT_YUV444M    | V4L2_PIX_FMT_YVU422M
+ * V4L2_PIX_FMT_YUV420M    | V4L2_PIX_FMT_YVU420M
+ * V4L2_PIX_FMT_NV12M      | V4L2_PIX_FMT_GREY
+ * V4L2_PIX_FMT_YUYV       | V4L2_PIX_FMT_YVYU
+ * V4L2_PIX_FMT_UYVY       | V4L2_PIX_FMT_VYUY
+ * V4L2_PIX_FMT_ABGR32     | V4L2_PIX_FMT_XBGR32
+ *
+ * ### Supported Pixel Formats for TNR
+ *  PIXEL FORMAT           | PIXEL FORMAT
+ * :---------------------: | :--------------:
+ * V4L2_PIX_FMT_YUV420M    | V4L2_PIX_FMT_NV12M
+ * V4L2_PIX_FMT_UYVY       | V4L2_PIX_FMT_YUYV
+ *
+ * ### Supported Memory Types
+ * MEMORY               | OUTPUT PLANE | CAPTURE PLANE
+ * :------------------: | :----------: | :-----------:
+ * V4L2_MEMORY_MMAP     | Y            | Y
+ * V4L2_MEMORY_DMABUF   | Y            | Y
+ * V4L2_MEMORY_USERPTR  | Y            | Y
+ *
+ * ### Supported Controls
+ * - #V4L2_CID_VIDEO_CONVERT_OUTPUT_PLANE_LAYOUT
+ * - #V4L2_CID_VIDEO_CONVERT_CAPTURE_PLANE_LAYOUT
+ * - #V4L2_CID_VIDEO_CONVERT_FLIP_METHOD
+ * - #V4L2_CID_VIDEO_CONVERT_INTERPOLATION_METHOD
+ * - #V4L2_CID_VIDEO_CONVERT_TNR_ALGORITHM
+ * - #V4L2_CID_VIDEO_CONVERT_YUV_RESCALE_METHOD
+ *
+ * ### Cropping
+ * Video converter supports cropping using \c VIDIOC_S_SELECTION IOCTL with type
+ * \c V4L2_BUF_TYPE_VIDEO_CAPTURE and target \c V4L2_SEL_TGT_CROP. This must
+ * be set before requesting buffers on either plane.
+ *
+ * ### EOS Handling
+ * The following sequence must be followed for sending EOS and recieving EOS
+ * from the converter.
+ * -# Send EOS to converter by queueing on the output plane a buffer with
+ * bytesused = 0 for the 0th plane (`v4l2_buffer.m.planes[0].bytesused = 0`).
+ * -# Dequeues buffers on the capture plane until it gets a buffer with bytesused = 0
+ * for the 0th plane.
+ *
+ * @note Currently, V4L2 plugins do not support odd resolution.
+ * @{
+ * @ingroup ee_extensions_group
+ */
+
+/**
+ * Defines the Control ID to set converter output plane buffer layout.
+ *
+ * A value of type \c v4l2_nv_buffer_layout must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on the output plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_OUTPUT_PLANE_LAYOUT   (V4L2_CID_MPEG_BASE+523)
+
+/**
+ * Defines the Control ID to set converter capture plane buffer layout.
+ *
+ * A value of type \c v4l2_nv_buffer_layout must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on the capture plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_CAPTURE_PLANE_LAYOUT  (V4L2_CID_MPEG_BASE+524)
+
+/**
+ * Defines the Control ID to set the converter flip/rotation method.
+ *
+ * A value of type \c v4l2_flip_method must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_FLIP_METHOD           (V4L2_CID_MPEG_BASE+525)
+
+/**
+ * Defines the Control ID to set the converter interpolation method.
+ *
+ * A value of type \c v4l2_interpolation_method must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_INTERPOLATION_METHOD  (V4L2_CID_MPEG_BASE+526)
+
+/**
+ * Defines the Control ID to set the converter Temporal Noise Reduction (TNR) algorithm.
+ *
+ * A value of type \c v4l2_tnr_algorithm must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ * @attention TNR algorithms are not supported with YUV422 and YUV444 capture
+ *            plane formats.
+ */
+#define V4L2_CID_VIDEO_CONVERT_TNR_ALGORITHM         (V4L2_CID_MPEG_BASE+527)
+/** @} */
+
+/**
+ * @defgroup V4L2Enc V4L2 Video Encoder
+ *
+ * @brief NVIDIA V4L2 Video Encoder Description and Extensions
+ *
+ * The video encoder device node is \c "/dev/nvhost-msenc".
+ *
+ * ### Supported Pixelformats
+ * OUTPUT PLANE            | CAPTURE PLANE
+ * :---------------------: | :--------------
+ * V4L2_PIX_FMT_YUV420M    | V4L2_PIX_FMT_H264
+ *           -             | V4L2_PIX_FMT_H265
+ *
+ * ### Supported Memory Types
+ * MEMORY               | OUTPUT PLANE | CAPTURE PLANE
+ * :------------------: | :----------: | :-----------:
+ * V4L2_MEMORY_MMAP     | Y            | Y
+ * V4L2_MEMORY_DMABUF   | Y            | N
+ * V4L2_MEMORY_USERPTR  | N            | N
+ * \attention For the video encoder, it is necessary that the capture plane
+ *  format be set before the output plane format and only then request buffers on
+ *  any of the planes.
+ *
+ * ### Supported Controls
+ * The following sections describe the supported controls.
+ *
+ * #### Controls From the Open Source V4L2-Controls Header
+ * Control ID                       | Purpose              | Runtime Configurable
+ * -------------------------------- | -------------------- | :------------------:
+ * V4L2_CID_MPEG_VIDEO_BITRATE      | Bitrate              | Y
+ * V4L2_CID_MPEG_VIDEO_H264_PROFILE | H.264 Encode Profile | N
+ * V4L2_CID_MPEG_VIDEO_BITRATE_MODE | Rate Control Mode    | N
+ * V4L2_CID_MPEG_VIDEO_GOP_SIZE     | I-frame Interval     | N
+ * V4L2_CID_MPEG_VIDEO_H264_LEVEL   | Encode Level         | N
+ * V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE | Force I-frame on one of queued output plane buffer | Y
+ *
+ * All non-runtime configurable options must be set after setting formats on
+ * both the planes and before requesting buffers on either plane.
+ *
+ * The runtime configurable parameters can be called anytime after setting
+ * formats on both the planes.
+ *
+ * #### NVIDIA-Specific Controls
+ * - #V4L2_CID_MPEG_VIDEO_H265_PROFILE
+ * - #V4L2_CID_MPEG_VIDEO_IDR_INTERVAL
+ * - #V4L2_CID_MPEG_VIDEOENC_TEMPORAL_TRADEOFF_LEVEL
+ * - #V4L2_CID_MPEG_VIDEOENC_SLICE_LENGTH_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_ROI_PARAMS
+ * - #V4L2_CID_MPEG_VIDEOENC_VIRTUALBUFFER_SIZE
+ * - #V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES
+ * - #V4L2_CID_MPEG_VIDEOENC_SLICE_INTRAREFRESH_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_NUM_BFRAMES
+ * - #V4L2_CID_MPEG_VIDEOENC_INSERT_SPS_PPS_AT_IDR
+ * - #V4L2_CID_MPEG_VIDEOENC_METADATA
+ * - #V4L2_CID_MPEG_VIDEOENC_METADATA_MV
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_METADATA_MV
+ * - #V4L2_CID_MPEG_VIDEOENC_QP_RANGE
+ * - #V4L2_CID_MPEG_VIDEOENC_HW_PRESET_TYPE_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RPS_CONTROL
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RATE_CONTROL
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_ROI_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_RECONCRC_PARAM
+ * - #V4L2_CID_MPEG_VIDEOENC_INSERT_VUI
+ * - #V4L2_CID_MPEG_VIDEOENC_INSERT_AUD
+ * - #V4L2_CID_MPEG_VIDEOENC_EXTEDED_COLORFORMAT
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_ALLIFRAME_ENCODE
+ * - #V4L2_CID_MPEG_VIDEOENC_H265_LEVEL
+ * - #V4L2_CID_MPEG_VIDEOENC_ENABLE_SLICE_LEVEL_ENCODE
+ *
+ * #### Setting Framerate
+ * The encoder framerate can be set with \c VIDIOC_S_PARM IOCTL by setting the numerator
+ * and denominator in `v4l2_streamparm.parm.output.timeperframe`.
+ *
+ * ### Supported Encoder Profiles
+ * #### H.264
+ * - V4L2_MPEG_VIDEO_H264_PROFILE_MAIN
+ * - V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE
+ * - V4L2_MPEG_VIDEO_H264_PROFILE_HIGH
+ *
+ * #### H.265
+ * - V4L2_MPEG_VIDEO_H265_PROFILE_MAIN
+ * - V4L2_MPEG_VIDEO_H265_PROFILE_MAIN10
+ *
+ * ### Encoder Output Metadata
+ * The encoder supports reporting frame related metadata, including motion vectors
+ * for that frame. See \c V4L2_CID_MPEG_VIDEOENC_METADATA,
+ * \c V4L2_CID_MPEG_VIDEOENC_METADATA_MV and \c V4L2_CID_MPEG_VIDEOENC_ENABLE_METADATA_MV
+ * for more information.
+ *
+ * ### EOS Handling
+ * The following sequence must be followed for sending EOS and recieving EOS
+ * from the encoder.
+ * -# Send EOS to encoder by queueing on the output plane a buffer with
+ * bytesused = 0 for the 0th plane (`v4l2_buffer.m.planes[0].bytesused = 0`).
+ * -# Dequeues buffers on the capture plane until it gets a buffer with bytesused = 0
+ * for the 0th plane.
+ *
+ * @note Currently, V4L2 plugins do not support odd resolution.
+ * @{
+ * @ingroup ee_extensions_group
+ */
+
+
+/**
+ * Defines the Control ID to configure encoder to drop frames while encoding.
+ *
+ * A value of type \c v4l2_enc_temporal_tradeoff_level_type must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_TEMPORAL_TRADEOFF_LEVEL (V4L2_CID_MPEG_BASE+528)
+
+/**
+ * Defines the Control ID to configure encoder slice length either in terms of MBs or bits.
+ *
+ * A pointer to a valid \c v4l2_enc_slice_length_param structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_SLICE_LENGTH_PARAM (V4L2_CID_MPEG_BASE+529)
+
+/**
+ * Defines the Control ID to configure encoder to encode particular region of frame in high
+ * quality.
+ *
+ * A pointer to a valid \c v4l2_enc_frame_ROI_params structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ROI_PARAMS (V4L2_CID_MPEG_BASE+530)
+
+/**
+ * Defines the Control ID to specify virtual buffer size in bits for encoder.
+ *
+ * A pointer to a valid \c v4l2_enc_virtual_buffer_size structure must be
+ * supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_VIRTUALBUFFER_SIZE (V4L2_CID_MPEG_BASE+531)
+
+/**
+ * Defines the Control ID to specify maximum number of reference frames that can be used.
+ *
+ * An integer value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES (V4L2_CID_MPEG_BASE+532)
+
+/**
+ * Defines the Control ID to specify the encoder slice intra refresh interval.
+ *
+ * A pointer to a valid \c v4l2_enc_slice_intrarefresh_param structure must be
+ * supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_SLICE_INTRAREFRESH_PARAM (V4L2_CID_MPEG_BASE+533)
+
+/**
+ * Defines the Control ID to set number of B frames to be encoded between two P frames.
+ *
+ * This works with H.264 encoder. This also works with H.265 encoder for Jetson Xavier and
+ * Jetson Xavier NX platforms. An integer value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_NUM_BFRAMES (V4L2_CID_MPEG_BASE+534)
+
+/**
+ * Defines the Control ID to enable/disable inserting SPS and PPS explicitly at IDR interval.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INSERT_SPS_PPS_AT_IDR (V4L2_CID_MPEG_BASE+535)
+
+/**
+ * Defines the Control ID to get encoder output metadata.
+ *
+ * A pointer to valid #v4l2_ctrl_video_metadata structure must be supplied with
+ * this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the capture plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_METADATA               (V4L2_CID_MPEG_BASE+536)
+
+/**
+ * Defines the Control ID to enable/disable encoder motion vector reporting.
+ *
+ * A boolean value must be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_METADATA_MV     (V4L2_CID_MPEG_BASE+537)
+
+/**
+ * Defines the Control ID to get encoder output motion vector metadata.
+ *
+ * A pointer to valid \c v4l2_ctrl_videoenc_outputbuf_metadata_MV structure must
+ * be supplied with this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the capture plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_METADATA_MV            (V4L2_CID_MPEG_BASE+538)
+
+/**
+ * Defines the Control ID to set QP range for I/P/B frames.
+ *
+ * A pointer to a valid \c v4l2_ctrl_video_qp_range structure must
+ * be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_QP_RANGE               (V4L2_CID_MPEG_BASE+539)
+
+/**
+ * Defines the Control ID to set encoder HW Preset type.
+ *
+ * A pointer to valid #v4l2_enc_hw_preset_type_param structure must
+ * be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_HW_PRESET_TYPE_PARAM   (V4L2_CID_MPEG_BASE+540)
+
+/**
+ * Defines the Control ID to provide input metadata for encoder buffer.
+ *
+ * A pointer to valid #v4l2_ctrl_videoenc_input_metadata structure must be
+ * supplied with this control.
+ *
+ * @attention This control must be called before queueing a buffer on the output
+ * plane. Use the bitwise OR of v4l2_enc_input_metadata_param in the
+ * v4l2_ctrl_videoenc_input_metadata.metadata_flag to provide different input
+ * metadata parameters in one s_ctrl call.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA         (V4L2_CID_MPEG_BASE+541)
+
+/**
+ * Defines the Control ID to configure encoder for external RPS control.
+ *
+ * A pointer to a valid #v4l2_enc_enable_ext_rps_ctr structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes. The value for V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES, if being entered,
+ * must be set after this control.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RPS_CONTROL (V4L2_CID_MPEG_BASE+542)
+
+/**
+ * Defines the Control ID to configure encoder for external rate control.
+ *
+ * A pointer to a valid #v4l2_enc_enable_ext_rate_ctr structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RATE_CONTROL (V4L2_CID_MPEG_BASE+543)
+
+/**
+ * Defines the Control ID to configure ROI encoding for a session.
+ *
+ * A pointer to a valid #v4l2_enc_enable_roi_param structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_ROI_PARAM (V4L2_CID_MPEG_BASE+544)
+
+/**
+ * Defines the Control ID to configure Reconstructed CRC for a session.
+ *
+ * A pointer to a valid #v4l2_enc_enable_reconcrc_param structure must be supplied
+ * with this control.
+ *
+ * @attention This control must be set after requesting buffers on both the
+ * planes.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_RECONCRC_PARAM  (V4L2_CID_MPEG_BASE+545)
+
+/**
+ * Control ID to enable/disable inserting VUI in SPS.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INSERT_VUI (V4L2_CID_MPEG_BASE+546)
+
+/**
+ * Control ID to enable/disable inserting AUD(Access Unit Delimiter).
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_INSERT_AUD (V4L2_CID_MPEG_BASE+547)
+
+/**
+ * Control ID to enable/disable setting extended color format.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane. Also this control should be
+ * enabled/disabled only after V4L2_CID_MPEG_VIDEOENC_INSERT_VUI is set
+ */
+#define V4L2_CID_MPEG_VIDEOENC_EXTEDED_COLORFORMAT (V4L2_CID_MPEG_BASE+548)
+
+/**
+ * Control ID to select which NVDEC IP to decode.
+ *
+ * @note This functionality is currently being deprecated and no longer
+ * functional.
+ *
+ * A v4l2_decode_instance_type should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_DECODE_INSTANCE (V4L2_CID_MPEG_BASE+549)
+/**
+ * Control ID to issue a pseudo POLL call on the fd opened in non blocking mode.
+ *
+ * A pointer to a valid #v4l2_ctrl_video_device_poll must be supplied with this control.
+ *
+ * @attention This should only be called when the Decoder or Encoder is opened with
+ * O_NONBLOCK flag.
+ */
+#define V4L2_CID_MPEG_VIDEO_DEVICE_POLL (V4L2_CID_MPEG_BASE+550)
+
+/**
+ * Control ID to set/clear the polling interrupt mode. Useful when a POLL issued from the
+ * application but wants the wait to be interrupted.
+ *
+ * A boolean value must be supplied with this control, True indicates polling interrupt shall be
+ * enabled and it shall stay enabled (i.e calls to POLL will return immediately) until a call to
+ * same control ID is made by passing a boolean 0 value.
+ *
+ * @attention This should only be called when the Decoder or Encoder is opened with
+ * O_NONBLOCK flag.
+ */
+#define V4L2_CID_MPEG_SET_POLL_INTERRUPT (V4L2_CID_MPEG_BASE+551)
+
+/**
+ * Control ID to enable/disable setting rate control two pass CBR.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_TWO_PASS_CBR (V4L2_CID_MPEG_BASE+552)
+
+/**
+ * Defines the Control ID to set the converter YUV Rescale method.
+ *
+ * A value of type \c v4l2_yuv_rescale_method must be supplied with this control.
+ *
+ * @attention This control must be set before requesting buffers on either plane.
+ */
+#define V4L2_CID_VIDEO_CONVERT_YUV_RESCALE_METHOD (V4L2_CID_MPEG_BASE+553)
+
+/**
+ * Control ID to enable maximum Performance.
+ *
+ * An integer value must be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_MAX_PERFORMANCE (V4L2_CID_MPEG_BASE+554)
+
+/**
+ * Control ID to enable/disable setting for all i-Frame encoding.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_ALLIFRAME_ENCODE (V4L2_CID_MPEG_BASE+555)
+
+/**
+ * Defines the Control ID to set buf api to be used by decoder/encoder.
+ *
+ * A boolean value should be supplied with this control, default is 0
+ * This has to be called before any other ioctls are used and cannot be changed.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ * This is internal ioctl due to be removed later.
+ */
+#define V4L2_CID_MPEG_VIDEO_BUF_API_TYPE (V4L2_CID_MPEG_BASE+556)
+
+/**
+ * Defines the Control ID to set cuda memory type to be used by decoder/encoder.
+ *
+ * This control can be used by the decoder to set the memory type for surfaces.
+ * A value of \c v4l2_cuda_mem_type needs to be set with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_CUDA_MEM_TYPE (V4L2_CID_MPEG_BASE+557)
+
+/**
+ * Defines the Control ID to set GPU ID to be used by decoder/encoder.
+ *
+ * An integer value should be supplied with this control.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEO_CUDA_GPU_ID (V4L2_CID_MPEG_BASE+558)
+
+/**
+ * Defines the Control ID to set drop frames interval for decoder.
+ *
+ * An integer value should be supplied with this control. A value of "x"
+ * indicates every "x"th frame should be given out from the decoder, rest shall
+ * dropped after decoding.
+ *
+ * @attention This control must be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEODEC_DROP_FRAME_INTERVAL (V4L2_CID_MPEG_BASE+559)
+
+/**
+ * Control ID to enable/disable setting for attaching VP8/9 headers.
+ * Only to be used for VP8/9 pixel format not for H264/5.
+ *
+ * A boolean value should be supplied with this control.
+ * If value is false headers will be disabled and true will enable the headers.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+ #define V4L2_CID_MPEG_VIDEOENC_VPX_HEADERS_WITH_FRAME (V4L2_CID_MPEG_BASE+560)
+
+/**
+ * Defines the control ID to set the H.265 encoder level.
+ *
+ * A v4l2_mpeg_video_h265_level must be passed.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_H265_LEVEL (V4L2_CID_MPEG_BASE+561)
+
+/**
+ * Control ID to enable/disable slice level encode output.
+ *
+ * A boolean value should be supplied with this control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_ENABLE_SLICE_LEVEL_ENCODE (V4L2_CID_MPEG_BASE+562)
+
+/**
+ * Defines the Control ID to set Picture Order Count property in frames.
+ *
+ * This works only with H.264 encoder. An integer value must be supplied with this
+ * control.
+ *
+ * @attention This control should be set after setting formats on both the planes
+ * and before requesting buffers on either plane.
+ */
+#define V4L2_CID_MPEG_VIDEOENC_POC_TYPE (V4L2_CID_MPEG_BASE+563)
+
+/** @} */
+
+/**
+ * @defgroup V4L2Argus V4L2 Video Camera
+ *
+ * @brief NVIDIA V4L2 Camera Description and Extensions
+ *
+ * The camera device node is \c "/dev/video%d".
+ *
+ * ### Supported Pixelformats
+ * CAPTURE PLANE
+ * :---------------------
+ * V4L2_PIX_FMT_NV12M
+ *           -
+ *
+ * ### Supported Memory Types
+ * MEMORY               | CAPTURE PLANE
+ * :------------------: | :-----------:
+ * V4L2_MEMORY_MMAP     | Y
+ * V4L2_MEMORY_DMABUF   | Y
+ * V4L2_MEMORY_USERPTR  | N
+ * \attention For the camera, it is necessary that the capture plane
+ *  format be set and only then request buffers.
+ *
+ * ### Supported Controls
+ * The following sections describe the supported controls.
+ *
+ * #### Controls From the Open Source V4L2-Controls Header
+ * Control ID                       | Purpose              | Runtime Configurable
+ * -------------------------------- | -------------------- | :------------------:
+ * - #V4L2_CID_3A_LOCK              | AWB/AE Lock          | Y
+ *
+ * All non-runtime configurable options must be set after setting format on
+ * the capture planes and before requesting buffers.
+ *
+ *
+ * ### NVIDIA-Specific Controls
+ * - #V4L2_CID_ARGUS_AUTO_WHITE_BALANCE_MODE
+ * - #V4L2_CID_ARGUS_SENSOR_MODE
+ * - #V4L2_CID_ARGUS_DENOISE_STRENGTH
+ * - #V4L2_CID_ARGUS_DENOISE_MODE
+ * - #V4L2_CID_ARGUS_EE_STRENGTH
+ * - #V4L2_CID_ARGUS_EE_MODE
+ * - #V4L2_CID_ARGUS_AE_ANTIBANDING_MODE
+ * - #V4L2_CID_ARGUS_ISP_DIGITAL_GAIN_RANGE
+ * - #V4L2_CID_ARGUS_COLOR_SATURATION
+ * - #V4L2_CID_ARGUS_GAIN_RANGE
+ * - #V4L2_CID_ARGUS_EXPOSURE_TIME_RANGE
+ * - #V4L2_CID_ARGUS_METADATA
+ *
+ * ### Setting Framerate
+ * The camera framerate can be set with \c VIDIOC_S_PARM IOCTL by setting the numerator
+ * and denominator in `v4l2_streamparm.parm.output.timeperframe`.
+ * Selection of camera mode can override this setting. If the camera mode is to be
+ * selected along with the specified framerate, then camera mode must be selected before
+ * setting the framerate.
+ *
+ * ### Camera Capture Metadata
+ * The camera can be queried to report frame related metadata. See \c V4L2_CID_ARGUS_METADATA
+ * for more information.
+ *
+ * ### EOS Handling
+ * Camera outputs all the queued empty buffers with data and TIME_OUT if no more empty buffers
+ * are queued. If error is encountered, am empty buffer is queued to the output with
+ * V4L2_BUF_FLAG_LAST flag.
+ * @{
+ * @ingroup ee_extensions_group
+ */
+/**
+ * Defines the Control ID to set auto white balance mode for camera.
+ *
+ * A value of type \c v4l2_argus_ac_awb_mode must be supplied
+ * with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_AUTO_WHITE_BALANCE_MODE (V4L2_CID_CAMERA_CLASS_BASE+20)
+
+/**
+ * Defines the Control ID to set sensor mode for camera.
+ *
+ * A non-negative integer value must be supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * and before requesting buffers on the capture plane.
+ */
+#define V4L2_CID_ARGUS_SENSOR_MODE (V4L2_CID_CAMERA_CLASS_BASE+32)
+
+/**
+ * Defines the Control ID to set denoise strength for camera.
+ *
+ * A pointer to a valid structure \c v4l2_argus_denoise_strength must be
+ * supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_DENOISE_STRENGTH (V4L2_CID_CAMERA_CLASS_BASE+33)
+
+/**
+ * Defines the Control ID to set denoise mode for camera.
+ *
+ * A value of type \c v4l2_argus_denoise_mode must be
+ * supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_DENOISE_MODE (V4L2_CID_CAMERA_CLASS_BASE+34)
+
+/**
+ * Defines the Control ID to set edge enhancement strength for camera.
+ *
+ * A pointer to a valid structure \c v4l2_argus_edge_enhance_strength
+ * must be supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_EE_STRENGTH (V4L2_CID_CAMERA_CLASS_BASE+35)
+
+/**
+ * Defines the Control ID to set edge enhancement mode for camera.
+ *
+ * A value of type \c v4l2_argus_edge_enhance_mode
+ * must be supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_EE_MODE (V4L2_CID_CAMERA_CLASS_BASE+36)
+
+/**
+ * Defines the Control ID to set Auto Exposure antibanding mode for camera.
+ *
+ * A value of type \c v4l2_argus_ac_ae_antibanding_mode must be supplied
+ * with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_AE_ANTIBANDING_MODE (V4L2_CID_CAMERA_CLASS_BASE+37)
+
+/**
+ * Defines the Control ID to set edge enhancement settings for camera.
+ *
+ * A pointer to a valid structure \c v4l2_argus_exposure_compensation
+ * must be supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_EXPOSURE_COMPENSATION (V4L2_CID_CAMERA_CLASS_BASE+38)
+
+/**
+ * Defines the Control ID to set edge enhancement settings for camera.
+ *
+ * A pointer to a valid structure \c v4l2_argus_ispdigital_gainrange
+ * must be supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_ISP_DIGITAL_GAIN_RANGE (V4L2_CID_CAMERA_CLASS_BASE+39)
+
+/**
+ * Defines the Control ID to set sensor mode for camera.
+ *
+ * A pointer to a valid structure \c v4l2_argus_color_saturation
+ * must be supplied with this control.
+ * The flag `EnableSaturation` must be set to true to enable setting
+ * the specified color saturation
+ *
+ * @attention This control should be set after setting format
+ * and before requesting buffers on the capture plane.
+ */
+#define V4L2_CID_ARGUS_COLOR_SATURATION (V4L2_CID_CAMERA_CLASS_BASE+40)
+
+/**
+ * Defines the Control ID to set edge enhancement settings for camera.
+ *
+ * A pointer to a valid structure \c v4l2_argus_gainrange
+ * must be supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_GAIN_RANGE (V4L2_CID_CAMERA_CLASS_BASE+41)
+
+/**
+ * Defines the Control ID to set edge enhancement settings for camera.
+ *
+ * A pointer to a valid structure \c v4l2_argus_exposure_timerange
+ * must be supplied with this control.
+ *
+ * @attention This control should be set after setting format
+ * on the capture plane.
+ */
+#define V4L2_CID_ARGUS_EXPOSURE_TIME_RANGE (V4L2_CID_CAMERA_CLASS_BASE+42)
+
+/**
+ * Defines the Control ID to get the camera argus output metadata.
+ *
+ * A pointer to a valid structure \c v4l2_argus_ctrl_metadata must be supplied
+ * with this control.
+ *
+ * @attention This control must be read after dequeueing a buffer successfully from
+ * the capture plane. The values in the structure are valid until the buffer is queued
+ * again.
+ */
+#define V4L2_CID_ARGUS_METADATA (V4L2_CID_CAMERA_CLASS_BASE+43)
+
+/** @} */
+
+/** @addtogroup V4L2Dec */
+/** @{ */
+/**
+ * Enum v4l2_skip_frames_type, possible methods for decoder skip frames. */
+enum v4l2_skip_frames_type {
+    /** Do not skip any frame. */
+    V4L2_SKIP_FRAMES_TYPE_NONE = 0,
+    /** Skip all non-reference frames. */
+    V4L2_SKIP_FRAMES_TYPE_NONREF = 1,
+    /** Skip all frames except IDR */
+    V4L2_SKIP_FRAMES_TYPE_DECODE_IDR_ONLY = 2,
+};
+
+/**
+ * Enum v4l2_cuda_mem_type, possible methods for cuda memory tpye. */
+enum v4l2_cuda_mem_type {
+    /** Memory type device. */
+    V4L2_CUDA_MEM_TYPE_DEVICE = 0,
+    /** Memory type host. */
+    V4L2_CUDA_MEM_TYPE_PINNED = 1,
+    /** Memory type unified. */
+    V4L2_CUDA_MEM_TYPE_UNIFIED = 2,
+};
+
+/**
+ * Enum v4l2_videodec_input_error_type, possible error types for input stream. */
+enum v4l2_videodec_input_error_type {
+    /** no error. */
+    V4L2_DEC_ERROR_NONE = 0x0,
+    /** sps error. */
+    V4L2_DEC_ERROR_SPS = 0x1,
+    /** pps error. */
+    V4L2_DEC_ERROR_PPS = 0x2,
+    /** slice header error. */
+    V4L2_DEC_ERROR_SLICE_HDR = 0x4,
+    /** missing reference frame error. */
+    V4L2_DEC_ERROR_MISSING_REF_FRAME = 0x8,
+    /** VPS error. */
+    V4L2_DEC_ERROR_VPS = 0x10,
+};
+
+/**
+ * Holds the decoder error status metadata for the frame.
+ */
+typedef struct v4l2_ctrl_videodec_statusmetadata_
+{
+    /** Error types:
+     *  bit 0: Fatal
+     *  bit 1: MB level syntax
+     *  bit 2: Missing Slice(s)
+     *  bit 3: PrevFrameLostFlag */
+    __u32  DecodeError;
+    /** Number of macro blocks decoded without error. */
+    __u32  DecodedMBs;
+    /** Number of macro blocks where error was concealed. */
+    __u32  ConcealedMBs;
+    /** POC of the reference frame used for concealment. */
+    __u32  nConcealedFromPOC;
+    /** Time required to decode the frame, in microseconds. */
+    __u32  FrameDecodeTime;
+}v4l2_ctrl_videodec_statusmetadata;
+
+/**
+ * Holds the the frame specific metadata for a reference frame.
+ */
+typedef struct v4l2_ctrl_videodec_refframe_metadata_
+{
+    /** Boolean value indicating if the frame is present in DPB. */
+    __u32 bPresent;
+    /** Boolean value indicating if the frame is an IDR. */
+    __u32 bIdrFrame;
+    /** Boolean value indicating if the frame is a long term reference frame. */
+    __u32 bLTRefFrame;
+    /** Boolean value indicating if it is a predicted frame. */
+    __u32 bPredicted;
+    /** Picture order count of the frame. */
+    __u32 nPictureOrderCnt;
+    /** Frame number. Resets to zero for an IDR frame. */
+    __u32 nFrameNum;
+    /** Long Term Frame Index of the frame. */
+    __u32 nLTRFrameIdx;
+} v4l2_ctrl_videodec_refframe_metadata;
+
+/**
+ * Holds the the frame specific metadata for the current frame.
+ */
+typedef struct v4l2_ctrl_videodec_currentframe_metadata_
+{
+    /** Boolean value indicating if the current frame is a reference frame. */
+    __u32 bRefFrame;
+    /** Boolean value indicating if the current frame is an IDR. */
+    __u32 bIdrFrame;
+    /** Boolean value indicating if the current frame is a long term reference frame. */
+    __u32 bLTRefFrame;
+    /** Picture order count of the current frame. */
+    __u32 nPictureOrderCnt;
+    /** Frame number. Resets to zero for an IDR frame. */
+    __u32 nFrameNum;
+    /** Long Term Frame Index of the current frame. */
+    __u32 nLTRFrameIdx;
+} v4l2_ctrl_videodec_currentframe_metadata;
+
+/**
+ * Holds the decoder DPB info metadata.
+ */
+typedef struct v4l2_ctrl_videodec_dpbinfometadata_
+{
+    /** Metadata for the current decoded frame. */
+    v4l2_ctrl_videodec_currentframe_metadata currentFrame;
+    /** Number of active frames present in the DPB. */
+    __u32 nActiveRefFrames;
+    /** An array of metadatas for the active frames in the DPB. Only
+     *  nActiveRefFrames elements in the array are valid. */
+    v4l2_ctrl_videodec_refframe_metadata RPSList[16];
+} v4l2_ctrl_videodec_dpbinfometadata;
+
+/**
+ * Holds H.264 specific decoder metadata for the frame.
+ */
+typedef struct v4l2_ctrl_h264dec_bufmetadata_
+{
+    /** Holds the number of bits in the frame. */
+    __u32 nFrameNumBits;
+    /** Type of frame:
+     *  0 = B
+     *  1 = P
+     *  2 = I */
+    __u32  FrameType;
+    /** Holds the current DPB information of the decoder. */
+    v4l2_ctrl_videodec_dpbinfometadata dpbInfo;
+}v4l2_ctrl_h264dec_bufmetadata;
+
+/**
+ * Holds H.265 specific decoder metadata for the frame.
+ */
+typedef struct v4l2_ctrl_hevcdec_bufmetadata_
+{
+    /** Holds the number of bits in the frame. */
+    __u32 nPocLsbBits;
+    /** Type of frame:
+     *  0 = B
+     *  1 = P
+     *  2 = I */
+    __u32  FrameType;
+    /** Holds the current DPB information of the decoder. */
+    v4l2_ctrl_videodec_dpbinfometadata dpbInfo;
+}v4l2_ctrl_hevcdec_bufmetadata;
+
+/**
+ * Holds the video decoder input header error metadata for a frame.
+ */
+typedef struct v4l2_ctrl_videodec_inputbuf_metadata_
+{
+    /** Bits represent types of error as defined
+     *  with v4l2_videodec_input_error_type. */
+    __u32 nBitStreamError;
+} v4l2_ctrl_videodec_inputbuf_metadata;
+
+/**
+ * Holds the video decoder output metadata for a frame.
+ */
+typedef struct v4l2_ctrl_videodec_outputbuf_metadata_
+{
+    /** Color primaries. */
+    __u8 ucColorPrimaries;
+    /** Transfer characteristics. */
+    __u8 ucTransferCharacteristics;
+    /** Matrix coefficients. */
+    __u8 ucMatrixCoefficients;
+    /** Boolean value indicating if \c FrameDecStats has valid contents. */
+    __u32 bValidFrameStatus;
+    /** Frame decode statistics. */
+    v4l2_ctrl_videodec_statusmetadata    FrameDecStats;
+    /** Codec specific metadata for the frame. */
+    union {
+        /** H.264 specific metadata. */
+        v4l2_ctrl_h264dec_bufmetadata H264DecParams;
+        /** H.265 specific metadata. */
+        v4l2_ctrl_hevcdec_bufmetadata HEVCDecParams;
+    }CodecParams;
+} v4l2_ctrl_videodec_outputbuf_metadata;
+/** @} */
+
+/** @addtogroup V4L2Enc */
+/** @{ */
+
+/**
+ * Specifies the types of encoder temporal tradeoff levels
+ */
+enum v4l2_enc_temporal_tradeoff_level_type {
+    /** Do not drop any buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROPNONE = 0,
+    /** Drop 1 in every 5 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP1IN5,
+    /** Drop 1 in every 3 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP1IN3,
+    /** Drop 1 in every 2 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP1IN2,
+    /** Drop 2 in every 3 buffers. */
+    V4L2_ENC_TEMPORAL_TRADEOFF_LEVEL_DROP2IN3,
+};
+
+/**
+ * Specifies the encoder HW Preset type.
+ */
+enum v4l2_enc_hw_preset_type {
+    /** Encoder HWPreset DISABLED. */
+    V4L2_ENC_HW_PRESET_DISABLE = 0,
+    /** Encoder HWPreset with per frame encode time UltraFast. */
+    V4L2_ENC_HW_PRESET_ULTRAFAST = 1,
+    /** Encoder HWPreset with per frame encode time Fast. */
+    V4L2_ENC_HW_PRESET_FAST,
+    /** Encoder HWPreset with per frame encode time Medium. */
+    V4L2_ENC_HW_PRESET_MEDIUM,
+    /** Encoder HWPreset with per frame encode time Slow. */
+    V4L2_ENC_HW_PRESET_SLOW,
+};
+
+/**
+ * Holds encoder HW Preset type parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_HW_PRESET_TYPE_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_hw_preset_type_param_
+{
+    /** Type in which the encoder hw preset is specified, one of type #v4l2_enc_hw_preset_type. */
+    enum v4l2_enc_hw_preset_type hw_preset_type;
+    /** Boolean value indicating if encoder set to max clock. */
+    __u8 set_max_enc_clock;
+}v4l2_enc_hw_preset_type_param;
+
+/**
+ * Enum specifying the type of slice length.
+ */
+enum v4l2_enc_slice_length_type {
+    /** Slice size is specified in terms of number of bytes. */
+    V4L2_ENC_SLICE_LENGTH_TYPE_BITS = 0,
+    /** Slice size is specified in terms of number of macroblocks. */
+    V4L2_ENC_SLICE_LENGTH_TYPE_MBLK,
+};
+
+/**
+ * Specifies the input buffer metadata flag.
+ */
+enum v4l2_enc_input_metadata_param {
+    /** Input metadata structure contains ROI parameters.  */
+    V4L2_ENC_INPUT_ROI_PARAM_FLAG = 1,
+    /** Input metadata structure contains GDR parameters.  */
+    V4L2_ENC_INPUT_GDR_PARAM_FLAG = 1 << 1,
+    /** Input metadata structure contains External RPS parameters.  */
+    V4L2_ENC_INPUT_RPS_PARAM_FLAG = 1 << 2,
+    /** Input metadata structure contains External RC parameters.  */
+    V4L2_ENC_INPUT_RC_PARAM_FLAG = 1 << 3,
+    /** Input metadata structure contains ReconCRC parameters.  */
+    V4L2_ENC_INPUT_RECONCRC_PARAM_FLAG = 1 << 4,
+};
+
+/**
+ * Defines the possible levels for H.265 encoder.
+ */
+enum v4l2_mpeg_video_h265_level {
+
+    V4L2_MPEG_VIDEO_H265_LEVEL_1_0_MAIN_TIER = 0,
+    V4L2_MPEG_VIDEO_H265_LEVEL_1_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_2_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_3_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_4_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_2_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_5_2_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_0_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_0_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_1_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_1_HIGH_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_2_MAIN_TIER,
+    V4L2_MPEG_VIDEO_H265_LEVEL_6_2_HIGH_TIER,
+};
+
+/**
+ * Holds encoder slice length parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_SLICE_LENGTH_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_slice_length_param_
+{
+    /** Type in which the slice length is specified, one of type \c v4l2_enc_slice_length_type. */
+    enum v4l2_enc_slice_length_type slice_length_type;
+    /** Size of the slice in either number of bytes or number of macro blocks. */
+    __u32   slice_length;
+}v4l2_enc_slice_length_param;
+
+/**
+ * Holds encoder virtual buffer size parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_VIRTUALBUFFER_SIZE IOCTL.
+ */
+typedef struct v4l2_enc_virtual_buffer_size_
+{
+    /** Size of the virtual buffer, in bits. */
+    __u32   size;
+}v4l2_enc_virtual_buffer_size;
+
+/**
+ * Holds encoder number of reference frame parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_NUM_REFERENCE_FRAMES IOCTL.
+ *
+ * This is not supported for H.265.
+ */
+typedef struct v4l2_enc_num_ref_frames_
+{
+    /** Number of reference frames. */
+    __u32   frames;
+}v4l2_enc_num_ref_frames;
+
+/**
+ * Holds encoder slice intrareferesh parameters, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_SLICE_INTRAREFRESH_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_slice_intrarefresh_param_
+{
+    /** Slice intrarefresh interval, in number of slices. */
+    __u32   interval;
+}v4l2_enc_slice_intrarefresh_param;
+
+/**
+ * Defines the maximum number of ROI regions supported by the encoder.
+ */
+#define V4L2_MAX_ROI_REGIONS 8
+
+/**
+ * Holds the encoder quality parameters for a single ROI region.
+ */
+typedef struct v4l2_enc_ROI_param_
+{
+    /** Region of interest rectangle. */
+    struct v4l2_rect  ROIRect;
+    /** QP delta for the region. */
+    __s32   QPdelta;
+} v4l2_enc_ROI_param;
+
+/**
+ * Holds the encoder frame ROI parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_ROI_PARAMS IOCTL.
+ */
+typedef struct v4l2_enc_frame_ROI_params_
+{
+    /** Number of regions. */
+    __u32 num_ROI_regions;
+    /** Array of indiviudal ROI parameters. */
+    v4l2_enc_ROI_param ROI_params[V4L2_MAX_ROI_REGIONS];
+    /** Config store integer to which this control is to be applied.
+     *  This must be same as the value of config store of \c v4l2_buffer to which
+     *  the ROI params is applied. */
+    __u32   config_store;
+}v4l2_enc_frame_ROI_params;
+
+/**
+ * Holds the motion vector parameters for a single block.
+ * For H.264, nvenc provides one motion vector per 16x16 block(Macroblock).
+ * For H.265, nvenc provides one motion vector per 32x32 block(Coded Tree Block).
+ */
+typedef struct MVInfo_ {
+    /** Number of pixels the macro block moved in horizontal direction. */
+    __s32 mv_x   : 16;
+    /** Number of pixels the macro block moved in vertical direction. */
+    __s32 mv_y   : 14;
+    /** Temporal hints used by hardware for Motion Estimation. */
+    __u32 weight : 2;
+} MVInfo;
+
+/**
+ * Holds the motion vector parameters for one complete frame.
+ */
+typedef struct v4l2_ctrl_videoenc_outputbuf_metadata_MV_ {
+    /** Size of the pMVInfo buffer, in bytes. */
+    __u32 bufSize;
+    /** Pointer to the buffer containing the motion vectors. */
+    MVInfo *pMVInfo;
+} v4l2_ctrl_videoenc_outputbuf_metadata_MV;
+
+/**
+ * Maximum number of reference frames supported by the encoder.
+ */
+#define V4L2_MAX_REF_FRAMES  8
+
+/**
+ * Holds the RPS List parameters of encoded frame.
+ */
+typedef struct v4l2_enc_frame_full_prop_
+{
+    /** Unique frame ID. */
+    __u32  nFrameId;
+    /** Boolean value indicating if current frame is an IDR. */
+    __u8   bIdrFrame;
+    /** Boolean value indicating if set Long Term Ref Flag. */
+    __u8   bLTRefFrame;
+    /** Picture Order Count. */
+    __u32  nPictureOrderCnt;
+    /** FrameNum. */
+    __u32  nFrameNum;
+    /** LongTermFrameIdx of a picture. */
+    __u32  nLTRFrameIdx;
+} v4l2_enc_frame_full_prop;
+
+/**
+ * Holds the encoder output metadata for a frame, to be used with
+ * \c V4L2_CID_MPEG_VIDEOENC_METADATA IOCTL.
+ */
+typedef struct v4l2_ctrl_videoenc_outputbuf_metadata_
+{
+    /** Boolean value indicating if current frame is a key frame. */
+    __u8 KeyFrame;
+    /** Boolean value indicating end of frame in case of multi slice encoding. */
+    __u8 EndofFrame;
+    /** Average QP value of the frame. */
+    __u16 AvgQP;
+    /** Boolean value indicating if current frame is a golden or alternate frame. */
+    __u8 bIsGoldenOrAlternateFrame;
+    /** CRC for Reconstructed frame. */
+    __u8 bValidReconCRC;
+    /** Recon Y-frame CRC */
+    __u32 ReconFrame_Y_CRC;
+    /** Recon U-frame CRC */
+    __u32 ReconFrame_U_CRC;
+    /** Recon V-frame CRC */
+    __u32 ReconFrame_V_CRC;
+    /** Number of bits needed to encode the frame. */
+    __u32 EncodedFrameBits;
+    /** Minumum QP value in the frame. */
+    __u32 FrameMinQP;
+    /** Maximum QP value in the frame. */
+    __u32 FrameMaxQP;
+    /** RPS Feedback. */
+    __u32 bRPSFeedback_status;
+    /**  Reference frame ID used for Motion Estimation of current frame,
+         ignored for IDR */
+    __u32 nCurrentRefFrameId;
+    /** Number of active reference frames. */
+    __u32 nActiveRefFrames;
+    /** RPS List including most recent frame if it is reference frame. */
+    v4l2_enc_frame_full_prop RPSList[V4L2_MAX_REF_FRAMES];
+} v4l2_ctrl_videoenc_outputbuf_metadata;
+
+/**
+ * Holds the metadata parameters for video encoder and decoder.
+ *
+ * The metadata is valid for the buffer with index \c buffer_index after the
+ * buffer is dequeued until it is queued again.
+ */
+typedef struct v4l2_ctrl_video_metadata_
+{
+    /** A pointer to #v4l2_ctrl_videodec_inputbuf_metadata structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEODEC_INPUT_METADATA
+     * IOCTL. */
+    v4l2_ctrl_videodec_inputbuf_metadata *VideoDecHeaderErrorMetadata;
+    /** A pointer to #v4l2_ctrl_videodec_outputbuf_metadata structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEODEC_METADATA
+     * IOCTL. */
+    v4l2_ctrl_videodec_outputbuf_metadata *VideoDecMetadata;
+    /** A pointer to #v4l2_ctrl_videoenc_outputbuf_metadata structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEOENC_METADATA
+     * IOCTL. */
+    v4l2_ctrl_videoenc_outputbuf_metadata *VideoEncMetadata;
+    /** A pointer to #v4l2_ctrl_videoenc_outputbuf_metadata_MV structure.
+     * This must be a valid pointer when used with #V4L2_CID_MPEG_VIDEOENC_METADATA_MV
+     * IOCTL. */
+    v4l2_ctrl_videoenc_outputbuf_metadata_MV *VideoEncMetadataMV;
+    /** Index of the buffer whose metadata is required. */
+    __u32 buffer_index;
+} v4l2_ctrl_video_metadata;
+
+/**
+ * Holds the encoder GDR parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_enc_gdr_params_
+{
+    /** Parameter for GDR (Intra Refresh) for specified number of frames. */
+    __u32 nGDRFrames;
+} v4l2_enc_gdr_params;
+
+/**
+ * Holds the params to configure encoder for external rps control
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RPS_CONTROL IOCTL.
+ */
+typedef struct v4l2_enc_enable_ext_rps_ctrl_
+{
+    /** Boolean value indicating if enabled External RPS control. */
+    __u8 bEnableExternalRPS;
+    /** Boolean value indicating if allowed gap in frame number. */
+    __u8 bGapsInFrameNumAllowed;
+    /* TODO : Check for field details. */
+    __u32 nH264FrameNumBits;
+    /* TODO : Check for field details. */
+    __u32 nH265PocLsbBits;
+}v4l2_enc_enable_ext_rps_ctr;
+
+
+/**
+ * Holds the encoder frame property.
+ */
+typedef struct _v4l2_enc_frame_prop
+{
+    /** unique Id. */
+    __u32 nFrameId;
+    /** Long Term Ref Flag. */
+    __u8 bLTRefFrame;
+} v4l2_enc_frame_prop;
+
+/**
+ * Holds the encoder frame external rps control parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_enc_frame_ext_rps_ctrl_params_
+{
+    /** unique Id of current frame. */
+    __u32 nFrameId;
+    /** Boolean value indicating if current frame referenced or non-referenced. */
+    __u8 bRefFrame;
+    /** Boolean value indicating if current frame long Term Ref Flag. */
+    __u8 bLTRefFrame;
+   /** Max Number of reference frames to use for inter-motion search. */
+    __u32 nMaxRefFrames;
+    /** # of valid entries in RPS, 0 means IDR. */
+    __u32 nActiveRefFrames;
+    /**  frame id of reference frame to be used for motion search, ignored for IDR. */
+    __u32 nCurrentRefFrameId;
+    /** Array of RPS */
+    v4l2_enc_frame_prop RPSList[V4L2_MAX_REF_FRAMES];
+}v4l2_enc_frame_ext_rps_ctrl_params;
+
+
+/**
+ * Holds the params to configure encoder for external rate control mode
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_EXTERNAL_RATE_CONTROL IOCTL.
+ */
+typedef struct v4l2_enc_enable_ext_rate_ctrl_
+{
+    /** Boolean value indicating if enabled External Picture RC. */
+    __u8 bEnableExternalPictureRC;
+    /** Max QP per session when external picture RC enabled. */
+    __u32 nsessionMaxQP;
+}v4l2_enc_enable_ext_rate_ctr;
+
+/**
+ * Holds the encoder frame external rate control parameters
+ * to be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA ioctl.
+ */
+typedef struct v4l2_enc_frame_ext_rate_ctrl_params_
+{
+    /** Target frame bits. */
+    __u32 nTargetFrameBits;
+    /** Frame start QP. */
+    __u32 nFrameQP;
+    /** Frame min QP. */
+    __u32 nFrameMinQp;
+    /** Frame max QP. */
+    __u32 nFrameMaxQp;
+    /** Frame min QP deviation. */
+    __u32 nMaxQPDeviation;
+}v4l2_enc_frame_ext_rate_ctrl_params;
+
+/**
+ * Holds the params to configure encoder for ROI parameters encoding
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_ROI_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_enable_roi_param_
+{
+    /** Boolean value to indicating ROI param encoding. */
+    __u8 bEnableROI;
+}v4l2_enc_enable_roi_param;
+
+/**
+ * Holds the params to configure encoder for Reconstructed CRC encoding
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_ENABLE_RECONCRC_PARAM IOCTL.
+ */
+typedef struct v4l2_enc_enable_reconcrc_param_
+{
+    /** Boolean value to indicating Reconstructed CRC encoding. */
+    __u8 bEnableReconCRC;
+}v4l2_enc_enable_reconcrc_param;
+
+/**
+ * Holds the encoder frame Reconstructed CRC parameters.
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_enc_frame_ReconCRC_params_
+{
+    /** Rectangle to specify the co-ordinates of the input frame
+    * used to calculate reconstructed picture CRC. */
+    struct v4l2_rect  ReconCRCRect;
+}v4l2_enc_frame_ReconCRC_params;
+
+/**
+ * Holds the encoder frame input metadata parameters.
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_INPUT_METADATA IOCTL.
+ */
+typedef struct v4l2_ctrl_videoenc_input_metadata_
+{
+    /** Flag to indicate which inputbuffer metadata is valid. */
+    __u32    flag;
+    /** Pointer to the ROI params structure when ROI param is in metadata_flag. */
+    v4l2_enc_frame_ROI_params *VideoEncROIParams;
+    /** Pointer to the Reconstructed CRC parameter structure when ReconCRC param is in
+    * metadata flag. */
+    v4l2_enc_frame_ReconCRC_params *VideoReconCRCParams;
+    /** Pointer to the GDR params structure when GDR param is in metadata_flag. */
+    v4l2_enc_gdr_params   *VideoEncGDRParams;
+    /** Pointer to the External RPL control parameter structure when RPS param is in
+    * metadata flag. */
+    v4l2_enc_frame_ext_rps_ctrl_params *VideoEncRPSParams;
+    /** Pointer to the External Rate control parameter structure when RC param is in
+    * metadata flag. */
+    v4l2_enc_frame_ext_rate_ctrl_params *VideoEncExtRCParams;
+    /** Config store integer to which these parameters are to be applied.
+     *  This must be same as the value of config store of queued v4l2_buffer
+     *   for which these parameters are valid. */
+    __u32    config_store;
+} v4l2_ctrl_videoenc_input_metadata;
+
+/**
+ * Setting Qp values in #v4l2_ctrl_video_qp_range to QP_RETAIN_VAL
+ * retains default or previously set QP values.
+ */
+#define QP_RETAIN_VAL -1
+
+/**
+ * Holds the encoder frame min/max QP parameters.
+ *
+ * Must be used with #V4L2_CID_MPEG_VIDEOENC_QP_RANGE IOCTL.
+ */
+typedef struct _v4l2_ctrl_video_qp_range
+{
+    /** Minimum QP value for I frame. */
+    __u32 MinQpI;
+    /** Maximum QP value for I frame. */
+    __u32 MaxQpI;
+    /** Minimum QP value for P frame. */
+    __u32 MinQpP;
+    /** Maximum QP value for P frame. */
+    __u32 MaxQpP;
+    /** Minimum QP value for B frame. */
+    __u32 MinQpB;
+    /** Maximum QP value for B frame. */
+    __u32 MaxQpB;
+} v4l2_ctrl_video_qp_range;
+/** @} */
+
+/** @addtogroup V4L2Argus */
+/** @{ */
+
+/**
+ * Enum specifying types of denoise modes.
+ */
+enum v4l2_argus_denoise_mode {
+    V4L2_ARGUS_DENOISE_MODE_UNKNOWN         = 0,
+    V4L2_ARGUS_DENOISE_MODE_OFF             = 1,
+    V4L2_ARGUS_DENOISE_MODE_FAST            = 2,
+    V4L2_ARGUS_DENOISE_MODE_HIGH_QUALITY    = 3,
+};
+
+/**
+ * Enum specifying types of edge enhancement modes.
+ */
+enum v4l2_argus_edge_enhance_mode {
+    V4L2_ARGUS_EDGE_ENHANCE_MODE_UNKNOWN        = 0,
+    V4L2_ARGUS_EDGE_ENHANCE_MODE_OFF            = 1,
+    V4L2_ARGUS_EDGE_ENHANCE_MODE_FAST           = 2,
+    V4L2_ARGUS_EDGE_ENHANCE_MODE_HIGH_QUALITY   = 3,
+};
+
+/**
+ * Enum specifying types of AE antibanding modes.
+ */
+enum v4l2_argus_ac_ae_antibanding_mode {
+    V4L2_ARGUS_AE_ANTIBANDING_MODE_UNKNOWN  = 0,
+    V4L2_ARGUS_AE_ANTIBANDING_MODE_OFF      = 1,
+    V4L2_ARGUS_AE_ANTIBANDING_MODE_AUTO     = 2,
+    V4L2_ARGUS_AE_ANTIBANDING_MODE_50HZ     = 3,
+    V4L2_ARGUS_AE_ANTIBANDING_MODE_60HZ     = 4,
+};
+
+/**
+ * Enum specifying types of AC AWB modes.
+ */
+enum v4l2_argus_ac_awb_mode {
+    V4L2_ARGUS_AWB_MODE_OFF               = 1,
+    V4L2_ARGUS_AWB_MODE_AUTO              = 2,
+    V4L2_ARGUS_AWB_MODE_INCANDESCENT      = 3,
+    V4L2_ARGUS_AWB_MODE_FLUORESCENT       = 4,
+    V4L2_ARGUS_AWB_MODE_WARM_FLUORESCENT  = 5,
+    V4L2_ARGUS_AWB_MODE_DAYLIGHT          = 6,
+    V4L2_ARGUS_AWB_MODE_CLOUDY_DAYLIGHT   = 7,
+    V4L2_ARGUS_AWB_MODE_TWILIGHT          = 8,
+    V4L2_ARGUS_AWB_MODE_SHADE             = 9,
+    V4L2_ARGUS_AWB_MODE_MANUAL            = 10,
+};
+
+/**
+ * Enum specifying types of AE states.
+ */
+enum v4l2_argus_ae_state {
+    V4L2_ARGUS_AeState_Unknown            = 0,
+    V4L2_ARGUS_AE_STATE_INACTIVE          = 1,
+    V4L2_ARGUS_AE_STATE_SEARCHING         = 2,
+    V4L2_ARGUS_AE_STATE_CONVERGED         = 3,
+    V4L2_ARGUS_AE_STATE_FLASH_REQUIRED    = 4,
+    V4L2_ARGUS_AE_STATE_TIMEOUT           = 5,
+};
+
+/**
+ * Enum specifying types of AWB states.
+ */
+enum v4l2_argus_awb_state {
+    V4L2_ARGUS_AwbState_Unknown           = 0,
+    V4L2_ARGUS_AWB_STATE_INACTIVE         = 1,
+    V4L2_ARGUS_AWB_STATE_SEARCHING        = 2,
+    V4L2_ARGUS_AWB_STATE_CONVERGED        = 3,
+    V4L2_ARGUS_AWB_STATE_LOCKED           = 4,
+};
+
+/**
+ * Holds the strength value for denoise operation.
+ *
+ * Must be used with #V4L2_CID_ARGUS_DENOISE_STRENGTH ioctl.
+ */
+typedef struct _v4l2_argus_denoise_strength
+{
+    /** Denoise Strength. Range: {-1.0f, 1.0f} **/
+    float DenoiseStrength;
+}v4l2_argus_denoise_strength;
+
+/**
+ * Holds the strength value for edge enhancement operation.
+ *
+ * Must be used with #V4L2_CID_ARGUS_EE_STRENGTH ioctl.
+ */
+typedef struct _v4l2_argus_edge_enhance_strength
+{
+    /** Edge Enhance Strength. Range: {-1.0f, 1.0f} **/
+    float EdgeEnhanceStrength;
+}v4l2_argus_edge_enhance_strength;
+
+/**
+ * Holds the value for exposure compensation.
+ *
+ * Must be used with #V4L2_CID_ARGUS_EXPOSURE_COMPENSATION ioctl.
+ */
+typedef struct _v4l2_argus_exposure_compensation
+{
+    /** Exposure Compensation. Range: {-2.0f, 2.0f} **/
+    float ExposureCompensation;
+}v4l2_argus_exposure_compensation;
+
+/**
+ * Holds the value for Isp Digital gain range.
+ *
+ * Must be used with #V4L2_CID_ARGUS_ISP_DIGITAL_GAIN_RANGE ioctl.
+ */
+typedef struct _v4l2_argus_ispdigital_gainrange
+{
+    /** Range: {1, 256} **/
+    /** Digital Gain Range start limit **/
+    float MinISPDigitalGainRange;
+    /** Digital Gain Range end limit **/
+    float MaxISPDigitalGainRange;
+}v4l2_argus_ispdigital_gainrange;
+
+/**
+ * Holds the value for absolute color saturation.
+ *
+ * Must be used with #V4L2_CID_ARGUS_COLOR_SATURATION ioctl.
+ */
+typedef struct _v4l2_argus_color_saturation
+{
+    /** Boolean value to indicate enable of user-specified absolute color saturation **/
+    __u8 EnableSaturation;
+    /** Specified absolute color saturation **/
+    float ColorSaturation;
+}v4l2_argus_color_saturation;
+
+/**
+ * Holds the value for gain range.
+ *
+ * Must be used with #V4L2_CID_ARGUS_GAIN_RANGE ioctl.
+ */
+typedef struct _v4l2_argus_gainrange
+{
+    /** Analog Gain Range start limit **/
+    float MinGainRange;
+    /** Analog Gain Range end limit **/
+    float MaxGainRange;
+}v4l2_argus_gainrange;
+
+/**
+ * Holds the value for exposure range.
+ *
+ * Must be used with #V4L2_CID_ARGUS_EXPOSURE_TIME_RANGE ioctl.
+ */
+typedef struct _v4l2_argus_exposure_timerange
+{
+    /** Exposure Time Range start limit **/
+    __u64 MinExposureTimeRange;
+    /** Exposure Time Range end limit **/
+    __u64 MaxExposureTimeRange;
+}v4l2_argus_exposure_timerange;
+
+/**
+ * Holds the value for camera output metadata.
+ *
+ * Must be used with #V4L2_CID_ARGUS_METADATA ioctl.
+ */
+typedef struct _v4l2_argus_ctrl_metadata
+{
+    /** Boolean value to indicate if AE was locked for this capture **/
+    __u8 AeLocked;
+    /** Boolean value to indicate if metadata has valid contents **/
+    __u8 ValidFrameStatus;
+    /** Index of the buffer captured **/
+    __u32 BufferIndex;
+    /** Focuser Position used for capture**/
+    __u32 FocuserPosition;
+    /** CCT value calculated by AWB **/
+    __u32 AwbCCT;
+    /** ISO value used for capture **/
+    __u32 SensorSensitivity;
+    /** Time (nanoseconds) taken to integrate the capture **/
+    __u64 FrameDuration;
+    /** Frame readout time for the capture **/
+    __u64 FrameReadoutTime;
+    /** Sensor Exposure time value for the capture **/
+    __u64 SensorExposureTime;
+    /** ISP Digital gain value for the capture **/
+    float IspDigitalGain;
+    /** Estimated scene brightness for the capture **/
+    float SceneLux;
+    /** Sensor analog gain for the capture **/
+    float SensorAnalogGain;
+    /** AE state ran for capture **/
+    enum v4l2_argus_ae_state AEState;
+    /** AWB state ran for capture **/
+    enum v4l2_argus_awb_state AWBState;
+}v4l2_argus_ctrl_metadata;
+/** @} */
+
+/** @addtogroup V4L2Conv */
+/** @{ */
+
+/**
+ * Enum specifying types of buffer layouts.
+ */
+enum v4l2_nv_buffer_layout {
+    V4L2_NV_BUFFER_LAYOUT_PITCH = 0,  /**< Pitch Linear Layout. */
+    V4L2_NV_BUFFER_LAYOUT_BLOCKLINEAR = 1, /**< Block Linear Layout. */
+};
+
+/**
+ * Specifies the types of rotation/flip algorithms.
+ */
+enum v4l2_flip_method {
+    V4L2_FLIP_METHOD_IDENTITY = 0, /**< Identity (no rotation). */
+    V4L2_FLIP_METHOD_90L = 1,      /**< Rotate counter-clockwise 90 degrees. */
+    V4L2_FLIP_METHOD_180 = 2,      /**< Rotate 180 degrees. */
+    V4L2_FLIP_METHOD_90R = 3,      /**< Rotate clockwise 90 degrees. */
+    V4L2_FLIP_METHOD_HORIZ = 4,    /**< Flip horizontally. */
+    V4L2_FLIP_METHOD_INVTRANS = 5, /**< Flip across upper right/lower left diagonal. */
+    V4L2_FLIP_METHOD_VERT = 6,     /**< Flip vertically. */
+    V4L2_FLIP_METHOD_TRANS = 7,    /**< Flip across upper left/lower right diagonal. */
+};
+
+/**
+ * Specifies the types of interpolation methods.
+ */
+enum v4l2_interpolation_method {
+  V4L2_INTERPOLATION_NEAREST = 1,   /**< Nearest interpolation method */
+  V4L2_INTERPOLATION_BILINEAR = 2,  /**< Bi-Linear interpolation method */
+  V4L2_INTERPOLATION_5_TAP = 3,     /**< 5-Tap interpolation method */
+  V4L2_INTERPOLATION_10_TAP = 4,    /**< 10-Tap interpolation method */
+  V4L2_INTERPOLATION_SMART = 5,     /**< Smart interpolation method */
+  V4L2_INTERPOLATION_NICEST = 6,    /**< Nicest interpolation method */
+};
+
+/**
+ * Specifies the types of TNR algorithms.
+ */
+enum v4l2_tnr_algorithm {
+  V4L2_TNR_ALGO_ORIGINAL = 0,           /**< Default TNR algorithm. */
+  V4L2_TNR_ALGO_OUTDOOR_LOW_LIGHT = 1,  /**< Outdoor Low Light TNR algorithm. */
+  V4L2_TNR_ALGO_OUTDOOR_MEDIUM_LIGHT = 2, /**< Outdoor Medium Light TNR algorithm. */
+  V4L2_TNR_ALGO_OUTDOOR_HIGH_LIGHT = 3, /**< Outdoor High Light TNR algorithm. */
+  V4L2_TNR_ALGO_INDOOR_LOW_LIGHT = 4, /**< Indoor Low Light TNR algorithm. */
+  V4L2_TNR_ALGO_INDOOR_MEDIUM_LIGHT = 5, /**< Indoor Medium Light TNR algorithm. */
+  V4L2_TNR_ALGO_INDOOR_HIGH_LIGHT = 6, /**< Indoor High Light TNR algorithm. */
+};
+
+/**
+ * Specifies the types of YUV rescale methods.
+ */
+enum v4l2_yuv_rescale_method {
+  /**< Disable */
+  V4L2_YUV_RESCALE_NONE = 0,
+  /**< Standard(limited range [16 235]) to extension(full range [0 255]) */
+  V4L2_YUV_RESCALE_STD_TO_EXT = 1,
+  /**< Extension(full range [0 255] to standard(limited range [16 235]) */
+  V4L2_YUV_RESCALE_EXT_TO_STD = 2,
+};
+
+typedef struct v4l2_ctrl_video_displaydata_
+{
+    __u32 masteringdisplaydatapresent;
+}v4l2_ctrl_video_displaydata;
+
+/**
+ * HDR Metadata.
+ */
+
+typedef struct _v4l2_ctrl_video_hdrmasteringdisplaydata
+{
+    // idx 0 : G, 1 : B, 2 : R
+    __u16 display_primaries_x[3];       // normalized x chromaticity cordinate. It shall be in the range of 0 to 50000
+    __u16 display_primaries_y[3];       // normalized y chromaticity cordinate. It shall be in the range of 0 to 50000
+    __u16 white_point_x;    // normalized x chromaticity cordinate of white point of mastering display
+    __u16 white_point_y;    // normalized y chromaticity cordinate of white point of mastering display
+    __u32 max_display_parameter_luminance;      // nominal maximum display luminance in units of 0.0001 candelas per square metre
+    __u32 min_display_parameter_luminance;      // nominal minimum display luminance in units of 0.0001 candelas per square metre
+} v4l2_ctrl_video_hdrmasteringdisplaydata;
+
+
+/**
+ * Poll device
+ */
+typedef struct _v4l2_ctrl_video_device_poll
+{
+    __u16 req_events;    // Requested events, a bitmask of POLLIN, POLLOUT, POLLERR, POLLPRI.
+    __u16 resp_events;    // Returned events a similar bitmask of above events.
+} v4l2_ctrl_video_device_poll;
+
+/** @} */
+#endif /*__V4L2_NV_EXTENSIONS_H__*/
diff --git a/media/gpu/v4l2/generic_v4l2_device.cc b/media/gpu/v4l2/generic_v4l2_device.cc
index 1338c53..15eaa00 100644
--- a/media/gpu/v4l2/generic_v4l2_device.cc
+++ b/media/gpu/v4l2/generic_v4l2_device.cc
@@ -42,6 +42,12 @@
 #include "media/gpu/v4l2/v4l2_stubs.h"
 #include "third_party/v4l-utils/lib/include/libv4l2.h"
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+// Auto-generated for dlopen nvbuf_utils libraries
+#include "media/gpu/nvbuf/nvbuf_stubs.h"
+#include "media/gpu/nvbuf/nvbuf_utils.h"
+#endif
+
 using media_gpu_v4l2::kModuleV4l2;
 using media_gpu_v4l2::InitializeStubs;
 using media_gpu_v4l2::StubPathMap;
@@ -69,6 +75,34 @@ int GenericV4L2Device::Ioctl(int request, void* arg) {
 }
 
 bool GenericV4L2Device::Poll(bool poll_device, bool* event_pending) {
+
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  v4l2_ctrl_video_device_poll devicepoll;
+  struct v4l2_ext_control control;
+  struct v4l2_ext_controls ctrls;
+
+  memset(&devicepoll, 0, sizeof(v4l2_ctrl_video_device_poll));
+  memset(&control, 0, sizeof(control));
+  memset(&ctrls, 0, sizeof(ctrls));
+
+  if (poll_device) {
+    devicepoll.req_events = POLLIN | POLLOUT | POLLERR | POLLPRI;
+
+    ctrls.count = 1;
+    ctrls.controls = &control;
+    control.id = V4L2_CID_MPEG_VIDEO_DEVICE_POLL;
+    control.string = (char *)&devicepoll;
+
+    if (Ioctl(VIDIOC_S_EXT_CTRLS, &ctrls) != 0) {
+      VPLOGF(1) << "poll() failed";
+      return false;
+    }
+    *event_pending = devicepoll.resp_events & POLLPRI;
+  }
+  else {
+    *event_pending = false;
+  }
+#else
   struct pollfd pollfds[2];
   nfds_t nfds;
   int pollfd = -1;
@@ -90,9 +124,20 @@ bool GenericV4L2Device::Poll(bool poll_device, bool* event_pending) {
     return false;
   }
   *event_pending = (pollfd != -1 && pollfds[pollfd].revents & POLLPRI);
+#endif
+
   return true;
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+void* GenericV4L2Device::Mmap(void* addr,
+                              unsigned int len,
+                              int prot,
+                              int flags, int fd,
+                              unsigned int offset) {
+  return mmap(addr, len, prot, flags, fd, offset);
+}
+#else
 void* GenericV4L2Device::Mmap(void* addr,
                               unsigned int len,
                               int prot,
@@ -101,6 +146,7 @@ void* GenericV4L2Device::Mmap(void* addr,
   DCHECK(device_fd_.is_valid());
   return mmap(addr, len, prot, flags, device_fd_.get(), offset);
 }
+#endif
 
 void GenericV4L2Device::Munmap(void* addr, unsigned int len) {
   munmap(addr, len);
@@ -108,19 +154,55 @@ void GenericV4L2Device::Munmap(void* addr, unsigned int len) {
 
 bool GenericV4L2Device::SetDevicePollInterrupt() {
   DVLOGF(4);
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  struct v4l2_ext_control control;
+  struct v4l2_ext_controls ctrls;
 
+  memset(&control, 0, sizeof(control));
+  memset(&ctrls, 0, sizeof(ctrls));
+
+  ctrls.count = 1;
+  ctrls.controls = &control;
+
+  control.id = V4L2_CID_MPEG_SET_POLL_INTERRUPT;
+  control.value = 1;
+
+  if(Ioctl(VIDIOC_S_EXT_CTRLS, &ctrls) != 0) {
+    VPLOGF(1) << "SetDevicePollInterrupt() failed";
+    return false;
+  }
+#else
   const uint64_t buf = 1;
   if (HANDLE_EINTR(write(device_poll_interrupt_fd_.get(), &buf, sizeof(buf))) ==
       -1) {
     VPLOGF(1) << "write() failed";
     return false;
   }
+#endif
+
   return true;
 }
 
 bool GenericV4L2Device::ClearDevicePollInterrupt() {
   DVLOGF(5);
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  struct v4l2_ext_control control;
+  struct v4l2_ext_controls ctrls;
+
+  memset(&control, 0, sizeof(control));
+  memset(&ctrls, 0, sizeof(ctrls));
+
+  ctrls.count = 1;
+  ctrls.controls = &control;
+
+  control.id = V4L2_CID_MPEG_SET_POLL_INTERRUPT;
+  control.value = 0;
 
+  if(Ioctl(VIDIOC_S_EXT_CTRLS, &ctrls) != 0) {
+    VPLOGF(1) << "ClearDevicePollInterrupt failed";
+    return false;
+  }
+#else
   uint64_t buf;
   if (HANDLE_EINTR(read(device_poll_interrupt_fd_.get(), &buf, sizeof(buf))) ==
       -1) {
@@ -132,6 +214,8 @@ bool GenericV4L2Device::ClearDevicePollInterrupt() {
       return false;
     }
   }
+#endif
+
   return true;
 }
 
@@ -212,6 +296,17 @@ bool GenericV4L2Device::CanCreateEGLImageFrom(const Fourcc fourcc) const {
          kEGLImageDrmFmtsSupported + base::size(kEGLImageDrmFmtsSupported);
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+EGLImageKHR GenericV4L2Device::CreateEGLImage(
+    EGLDisplay egl_display,
+    EGLContext /* egl_context */,
+    GLuint texture_id,
+    const gfx::Size& size,
+    unsigned int buffer_index,
+    const Fourcc fourcc,
+    gfx::NativePixmapHandle handle,
+    int32_t dmabuf_fd) const {
+#else
 EGLImageKHR GenericV4L2Device::CreateEGLImage(
     EGLDisplay egl_display,
     EGLContext /* egl_context */,
@@ -220,8 +315,11 @@ EGLImageKHR GenericV4L2Device::CreateEGLImage(
     unsigned int buffer_index,
     const Fourcc fourcc,
     gfx::NativePixmapHandle handle) const {
+#endif
   DVLOGF(3);
 
+  EGLImageKHR egl_image = EGL_NO_IMAGE_KHR;
+
   if (!CanCreateEGLImageFrom(fourcc)) {
     VLOGF(1) << "Unsupported V4L2 pixel format";
     return EGL_NO_IMAGE_KHR;
@@ -251,8 +349,17 @@ EGLImageKHR GenericV4L2Device::CreateEGLImage(
 
   attrs.push_back(EGL_NONE);
 
-  EGLImageKHR egl_image = eglCreateImageKHR(
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  if (dmabuf_fd != -1) {
+    egl_image = NvEGLImageFromFd(egl_display, dmabuf_fd);
+  }
+  else {
+#else
+       {
+#endif
+    egl_image = eglCreateImageKHR(
       egl_display, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, NULL, &attrs[0]);
+  }
   if (egl_image == EGL_NO_IMAGE_KHR) {
     VLOGF(1) << "Failed creating EGL image: " << ui::GetLastEGLErrorString();
     return egl_image;
@@ -306,6 +413,7 @@ scoped_refptr<gl::GLImage> GenericV4L2Device::CreateGLImage(
 EGLBoolean GenericV4L2Device::DestroyEGLImage(EGLDisplay egl_display,
                                               EGLImageKHR egl_image) const {
   DVLOGF(3);
+  /* NvDestroyEGLImage internally calls same fxn */
   EGLBoolean result = eglDestroyImageKHR(egl_display, egl_image);
   if (result != EGL_TRUE) {
     LOG(WARNING) << "Destroy EGLImage failed.";
@@ -410,7 +518,11 @@ bool GenericV4L2Device::OpenDevicePath(const std::string& path, Type type) {
   DCHECK(!device_fd_.is_valid());
 
   device_fd_.reset(
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+      HANDLE_EINTR(open(path.c_str(), O_NONBLOCK)));
+#else
       HANDLE_EINTR(open(path.c_str(), O_RDWR | O_NONBLOCK | O_CLOEXEC)));
+#endif
   if (!device_fd_.is_valid())
     return false;
 
@@ -447,10 +559,22 @@ bool GenericV4L2Device::PostSandboxInitialization() {
 #else
       FILE_PATH_LITERAL("/usr/lib/libv4l2.so");
 #endif  // defined(ARCH_CPU_64_BITS)
+
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  static const base::FilePath::CharType kNvBufUtils[] =
+      FILE_PATH_LITERAL( "/usr/lib/aarch64-linux-gnu/tegra/libnvbuf_utils.so" );
+  StubPathMap v4l2paths;
+  media_gpu_nvbuf::StubPathMap nvbufpaths;
+  v4l2paths[kModuleV4l2].push_back(kV4l2Lib);
+  nvbufpaths[media_gpu_nvbuf::kModuleNvbuf].push_back(kNvBufUtils);
+  bool retval = InitializeStubs(v4l2paths) && media_gpu_nvbuf::InitializeStubs(nvbufpaths);
+  return retval;
+#else
   StubPathMap paths;
   paths[kModuleV4l2].push_back(kV4l2Lib);
 
   return InitializeStubs(paths);
+#endif
 #else
   return true;
 #endif
diff --git a/media/gpu/v4l2/generic_v4l2_device.h b/media/gpu/v4l2/generic_v4l2_device.h
index 478f23b..857e5fd 100644
--- a/media/gpu/v4l2/generic_v4l2_device.h
+++ b/media/gpu/v4l2/generic_v4l2_device.h
@@ -19,6 +19,9 @@
 #include "media/gpu/buildflags.h"
 #include "media/gpu/v4l2/v4l2_device.h"
 #include "ui/gfx/native_pixmap_handle.h"
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+#include "media/gpu/nvbuf/v4l2_nv_extensions.h"
+#endif
 
 namespace media {
 
@@ -32,11 +35,19 @@ class GenericV4L2Device : public V4L2Device {
   bool Poll(bool poll_device, bool* event_pending) override;
   bool SetDevicePollInterrupt() override;
   bool ClearDevicePollInterrupt() override;
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  void* Mmap(void* addr,
+             unsigned int len,
+             int prot,
+             int flags, int fd,
+             unsigned int offset) override;
+#else
   void* Mmap(void* addr,
              unsigned int len,
              int prot,
              int flags,
              unsigned int offset) override;
+#endif
   void Munmap(void* addr, unsigned int len) override;
 
   std::vector<base::ScopedFD> GetDmabufsForV4L2Buffer(
@@ -45,6 +56,16 @@ class GenericV4L2Device : public V4L2Device {
       enum v4l2_buf_type buf_type) override;
 
   bool CanCreateEGLImageFrom(const Fourcc fourcc) const override;
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  EGLImageKHR CreateEGLImage(EGLDisplay egl_display,
+                             EGLContext egl_context,
+                             GLuint texture_id,
+                             const gfx::Size& size,
+                             unsigned int buffer_index,
+                             const Fourcc fourcc,
+                             gfx::NativePixmapHandle handle,
+                             int32_t dmabuf_fd = -1) const override;
+#else
   EGLImageKHR CreateEGLImage(EGLDisplay egl_display,
                              EGLContext egl_context,
                              GLuint texture_id,
@@ -52,6 +73,7 @@ class GenericV4L2Device : public V4L2Device {
                              unsigned int buffer_index,
                              const Fourcc fourcc,
                              gfx::NativePixmapHandle handle) const override;
+#endif
 
   scoped_refptr<gl::GLImage> CreateGLImage(
       const gfx::Size& size,
diff --git a/media/gpu/v4l2/v4l2_device.cc b/media/gpu/v4l2/v4l2_device.cc
index daab0b8..fd93982 100644
--- a/media/gpu/v4l2/v4l2_device.cc
+++ b/media/gpu/v4l2/v4l2_device.cc
@@ -98,6 +98,9 @@ class V4L2Buffer {
 
   void* GetPlaneMapping(const size_t plane);
   size_t GetMemoryUsage() const;
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  int32_t GetFD();
+#endif
   const struct v4l2_buffer& v4l2_buffer() const { return v4l2_buffer_; }
   scoped_refptr<VideoFrame> GetVideoFrame();
 
@@ -108,6 +111,9 @@ class V4L2Buffer {
              const struct v4l2_format& format,
              size_t buffer_id);
   bool Query();
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  int32_t fd;
+#endif
   scoped_refptr<VideoFrame> CreateVideoFrame();
 
   scoped_refptr<V4L2Device> device_;
@@ -160,6 +166,9 @@ V4L2Buffer::V4L2Buffer(scoped_refptr<V4L2Device> device,
   v4l2_buffer_.index = buffer_id;
   v4l2_buffer_.type = type;
   v4l2_buffer_.memory = memory;
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  fd = 0;
+#endif
   plane_mappings_.resize(v4l2_buffer_.length);
 }
 
@@ -180,6 +189,28 @@ bool V4L2Buffer::Query() {
 
   DCHECK(plane_mappings_.size() == v4l2_buffer_.length);
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  // This is required for mmap with actual allocated buffer FDs
+
+  struct v4l2_exportbuffer export_buf_;
+  memset(&export_buf_, 0, sizeof (struct v4l2_exportbuffer));
+  export_buf_.type = v4l2_buffer_.type;
+  export_buf_.index = v4l2_buffer_.index;
+
+  if (v4l2_buffer_.type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE ||
+      v4l2_buffer_.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+    // For Tegra, MMAP buffer fd is exported for plane,
+    // so hardcoding VIDIOC_EXPBUF to a single plane for now.
+    export_buf_.plane = 0;
+
+    int ret = device_->Ioctl(VIDIOC_EXPBUF, &export_buf_);
+    if (ret) {
+      VPLOGF(1) << "VIDIOC_EXPBUF failed: ";
+      return false;
+    }
+    fd = export_buf_.fd;
+  }
+#endif
   return true;
 }
 
@@ -200,9 +231,15 @@ void* V4L2Buffer::GetPlaneMapping(const size_t plane) {
     return nullptr;
   }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  p = device_->Mmap(nullptr, v4l2_buffer_.m.planes[plane].length,
+                    PROT_READ | PROT_WRITE, MAP_SHARED, fd,
+                    v4l2_buffer_.m.planes[plane].m.mem_offset);
+#else
   p = device_->Mmap(nullptr, v4l2_buffer_.m.planes[plane].length,
                     PROT_READ | PROT_WRITE, MAP_SHARED,
                     v4l2_buffer_.m.planes[plane].m.mem_offset);
+#endif
   if (p == MAP_FAILED) {
     VPLOGF(1) << "mmap() failed: ";
     return nullptr;
@@ -212,6 +249,12 @@ void* V4L2Buffer::GetPlaneMapping(const size_t plane) {
   return p;
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+int32_t V4L2Buffer::GetFD() {
+  return fd;
+}
+#endif
+
 size_t V4L2Buffer::GetMemoryUsage() const {
   size_t usage = 0;
   for (size_t i = 0; i < v4l2_buffer_.length; i++) {
@@ -235,6 +278,10 @@ scoped_refptr<VideoFrame> V4L2Buffer::CreateVideoFrame() {
     return nullptr;
   }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  fd = dmabuf_fds.back().get();
+#endif
+
   // Duplicate the fd of the last v4l2 plane until the number of fds are the
   // same as the number of color planes.
   while (dmabuf_fds.size() != layout->planes().size()) {
@@ -348,6 +395,9 @@ class V4L2BufferRefBase {
 
   bool QueueBuffer(scoped_refptr<VideoFrame> video_frame);
   void* GetPlaneMapping(const size_t plane);
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  int32_t GetFD();
+#endif
 
   scoped_refptr<VideoFrame> GetVideoFrame();
   // Checks that the number of passed FDs is adequate for the current format
@@ -435,6 +485,12 @@ scoped_refptr<VideoFrame> V4L2BufferRefBase::GetVideoFrame() {
   return queue_->buffers_[BufferId()]->GetVideoFrame();
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+int32_t V4L2BufferRefBase::GetFD() {
+  return queue_->buffers_[BufferId()]->GetFD();
+}
+#endif
+
 bool V4L2BufferRefBase::CheckNumFDsForFormat(const size_t num_fds) const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
@@ -510,6 +566,12 @@ scoped_refptr<VideoFrame> V4L2WritableBufferRef::GetVideoFrame() {
   return buffer_data_->GetVideoFrame();
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+int32_t V4L2WritableBufferRef::GetFD() {
+  return buffer_data_->GetFD();
+}
+#endif
+
 enum v4l2_memory V4L2WritableBufferRef::Memory() const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(buffer_data_);
@@ -872,6 +934,12 @@ size_t V4L2ReadableBuffer::GetPlaneDataOffset(const size_t plane) const {
   return buffer_data_->v4l2_planes_[plane].data_offset;
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+int32_t V4L2ReadableBuffer::GetFD() {
+  return buffer_data_->GetFD();
+}
+#endif
+
 size_t V4L2ReadableBuffer::BufferId() const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(buffer_data_);
@@ -988,6 +1056,13 @@ std::pair<base::Optional<struct v4l2_format>, int> V4L2Queue::GetFormat() {
     return std::make_pair(base::nullopt, errno);
   }
 
+#if BUILDFLAG (USE_NVIDIA_V4L2)
+  // Workaround tegra v4l2 bug that doesn't send num_planes for OUTPUT_MPLANE
+  if (type_ == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+    format.fmt.pix_mp.num_planes = 1;
+  }
+#endif
+
   return std::make_pair(format, 0);
 }
 
@@ -1265,6 +1340,21 @@ std::pair<bool, V4L2ReadableBufferRef> V4L2Queue::DequeueBuffer() {
   if (ret) {
     // TODO(acourbot): we should not have to check for EPIPE as codec clients
     // should not call this method after the last buffer is dequeued.
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+    switch (errno) {
+      case EAGAIN:
+        // This is not an error so we'll need to continue polling but won't
+        // provide a buffer.
+        // usleep(17000); /*This was kept for testing purpose on CPU usage*/
+        device_->SchedulePoll();
+        return std::make_pair(true, nullptr);
+      case EPIPE:
+        return std::make_pair(false, nullptr);
+      default:
+        LOG(ERROR) << "Error in Dequeue output buffer";
+        return std::make_pair(false, nullptr);
+    }
+#else
     switch (errno) {
       case EAGAIN:
       case EPIPE:
@@ -1276,6 +1366,7 @@ std::pair<bool, V4L2ReadableBufferRef> V4L2Queue::DequeueBuffer() {
         VPQLOGF(1) << "VIDIOC_DQBUF failed";
         return std::make_pair(false, nullptr);
     }
+#endif
   }
 
   auto it = queued_buffers_.find(v4l2_buffer.index);
@@ -1468,6 +1559,8 @@ uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
     return V4L2_PIX_FMT_H264;
   } else if (profile >= VP8PROFILE_MIN && profile <= VP8PROFILE_MAX) {
     return V4L2_PIX_FMT_VP8;
+  } else if (profile >= VP9PROFILE_MIN && profile <= VP9PROFILE_MAX) {
+    return V4L2_PIX_FMT_VP9;
   } else {
     LOG(FATAL) << "Add more cases as needed";
     return 0;
@@ -1612,16 +1705,16 @@ std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
 #endif
       profiles = {VP8PROFILE_ANY};
       break;
-#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_VP9:
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_VP9_FRAME:
+#endif
       if (!get_supported_profiles(kCodecVP9, &profiles)) {
         DLOG(WARNING) << "Driver doesn't support QUERY VP9 profiles, "
                       << "use default values, Profile0";
         profiles = {VP9PROFILE_PROFILE0};
       }
       break;
-#endif
     default:
       VLOGF(1) << "Unhandled pixelformat " << FourccToString(pix_fmt);
       return {};
@@ -2252,8 +2345,23 @@ bool V4L2Device::SetExtCtrls(uint32_t ctrl_class,
 
 base::Optional<struct v4l2_ext_control> V4L2Device::GetCtrl(uint32_t ctrl_id) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(client_sequence_checker_);
+
   struct v4l2_ext_control ctrl;
   memset(&ctrl, 0, sizeof(ctrl));
+
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  struct v4l2_control v4l2_ctrl;
+  memset(&v4l2_ctrl, 0, sizeof(v4l2_ctrl));
+
+  v4l2_ctrl.id = ctrl_id;
+
+  if (Ioctl(VIDIOC_G_CTRL, &v4l2_ctrl) != 0) {
+    VPLOGF(3) << "Failed to get control";
+    return base::nullopt;
+  }
+  ctrl.id = v4l2_ctrl.id;
+  ctrl.value = v4l2_ctrl.value;
+#else
   struct v4l2_ext_controls ext_ctrls;
   memset(&ext_ctrls, 0, sizeof(ext_ctrls));
 
@@ -2265,7 +2373,7 @@ base::Optional<struct v4l2_ext_control> V4L2Device::GetCtrl(uint32_t ctrl_id) {
     VPLOGF(3) << "Failed to get control";
     return base::nullopt;
   }
-
+#endif
   return ctrl;
 }
 
diff --git a/media/gpu/v4l2/v4l2_device.h b/media/gpu/v4l2/v4l2_device.h
index 38bbe75..616fef4 100644
--- a/media/gpu/v4l2/v4l2_device.h
+++ b/media/gpu/v4l2/v4l2_device.h
@@ -173,6 +173,10 @@ class MEDIA_GPU_EXPORT V4L2WritableBufferRef {
   // return nullptr for any other buffer type.
   scoped_refptr<VideoFrame> GetVideoFrame() WARN_UNUSED_RESULT;
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  int32_t GetFD() WARN_UNUSED_RESULT;
+#endif
+
   // Return the V4L2 buffer ID of the underlying buffer.
   // TODO(acourbot) This is used for legacy clients but should be ultimately
   // removed. See crbug/879971
@@ -249,6 +253,10 @@ class MEDIA_GPU_EXPORT V4L2ReadableBuffer
   // return nullptr for any other buffer type.
   scoped_refptr<VideoFrame> GetVideoFrame() WARN_UNUSED_RESULT;
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  int32_t GetFD() WARN_UNUSED_RESULT;
+#endif
+
  private:
   friend class V4L2BufferRefFactory;
   friend class base::RefCountedThreadSafe<V4L2ReadableBuffer>;
@@ -676,11 +684,19 @@ class MEDIA_GPU_EXPORT V4L2Device
   virtual bool ClearDevicePollInterrupt() = 0;
 
   // Wrappers for standard mmap/munmap system calls.
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  virtual void* Mmap(void* addr,
+                     unsigned int len,
+                     int prot,
+                     int flags, int fd,
+                     unsigned int offset) = 0;
+#else
   virtual void* Mmap(void* addr,
                      unsigned int len,
                      int prot,
                      int flags,
                      unsigned int offset) = 0;
+#endif
   virtual void Munmap(void* addr, unsigned int len) = 0;
 
   // Return a vector of dmabuf file descriptors, exported for V4L2 buffer with
@@ -700,6 +716,16 @@ class MEDIA_GPU_EXPORT V4L2Device
   // Some implementations may also require the V4L2 |buffer_index| of the buffer
   // for which |handle| has been exported.
   // Return EGL_NO_IMAGE_KHR on failure.
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  virtual EGLImageKHR CreateEGLImage(EGLDisplay egl_display,
+                                     EGLContext egl_context,
+                                     GLuint texture_id,
+                                     const gfx::Size& size,
+                                     unsigned int buffer_index,
+                                     const Fourcc fourcc,
+                                     gfx::NativePixmapHandle handle,
+                                     int32_t dmabuf_fd = -1) const = 0;
+#else
   virtual EGLImageKHR CreateEGLImage(EGLDisplay egl_display,
                                      EGLContext egl_context,
                                      GLuint texture_id,
@@ -707,6 +733,7 @@ class MEDIA_GPU_EXPORT V4L2Device
                                      unsigned int buffer_index,
                                      const Fourcc fourcc,
                                      gfx::NativePixmapHandle handle) const = 0;
+#endif
 
   // Create a GLImage from provided |handle|, taking full ownership of it.
   virtual scoped_refptr<gl::GLImage> CreateGLImage(
diff --git a/media/gpu/v4l2/v4l2_video_decode_accelerator.cc b/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
index e5ef6b9..030c9d2 100644
--- a/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
+++ b/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
@@ -43,6 +43,10 @@
 #include "ui/gl/gl_context.h"
 #include "ui/gl/scoped_binders.h"
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+#include "media/gpu/nvbuf/nvbuf_utils.h"
+#endif
+
 #define NOTIFY_ERROR(x)                      \
   do {                                       \
     VLOGF(1) << "Setting error state:" << x; \
@@ -74,10 +78,7 @@ namespace media {
 
 // static
 const uint32_t V4L2VideoDecodeAccelerator::supported_input_fourccs_[] = {
-    V4L2_PIX_FMT_H264, V4L2_PIX_FMT_VP8,
-#if !BUILDFLAG(USE_LINUX_V4L2)
-    V4L2_PIX_FMT_VP9,
-#endif
+    V4L2_PIX_FMT_H264, V4L2_PIX_FMT_VP8, V4L2_PIX_FMT_VP9,
 };
 
 // static
@@ -221,7 +222,7 @@ bool V4L2VideoDecodeAccelerator::Initialize(const Config& config,
     }
 
 // TODO(posciak): https://crbug.com/450898.
-#if defined(ARCH_CPU_ARMEL)
+#if defined(ARCH_CPU_ARMEL) || defined(ARCH_CPU_ARM64)
     if (!gl::g_driver_egl.ext.b_EGL_KHR_fence_sync) {
       VLOGF(1) << "context does not have EGL_KHR_fence_sync";
       return false;
@@ -287,6 +288,13 @@ void V4L2VideoDecodeAccelerator::InitializeTask(const Config& config,
   sub.type = V4L2_EVENT_SOURCE_CHANGE;
   IOCTL_OR_ERROR_RETURN(VIDIOC_SUBSCRIBE_EVENT, &sub);
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  // Subscribe to the EOS event.
+  memset(&sub, 0, sizeof(sub));
+  sub.type = V4L2_EVENT_EOS;
+  IOCTL_OR_ERROR_RETURN(VIDIOC_SUBSCRIBE_EVENT, &sub);
+#endif
+
   if (!CreateInputBuffers()) {
     LOG(ERROR) << "Failed CreatingInputBuffers()";
     NOTIFY_ERROR(PLATFORM_FAILURE);
@@ -446,10 +454,18 @@ void V4L2VideoDecodeAccelerator::AssignPictureBuffersTask(
 
     // We move the buffer into output_wait_map_, so get a reference to
     // its video frame if we need it to create the native pixmap for import.
+#if !BUILDFLAG(USE_NVIDIA_V4L2)
     scoped_refptr<VideoFrame> video_frame;
     if (output_mode_ == Config::OutputMode::ALLOCATE &&
         !image_processor_device_)
       video_frame = buffer.GetVideoFrame();
+#else
+    int32_t dmabuf_fd = -1;
+    dmabuf_fd = buffer.GetFD();
+    /*Export Buffer called already. mmap for each plane directly */
+    buffer.GetPlaneMapping(0);
+    buffer.GetPlaneMapping(1);
+#endif
 
     // The buffer will remain here until ImportBufferForPicture is called,
     // either by the client, or by ourselves, if we are allocating.
@@ -462,12 +478,17 @@ void V4L2VideoDecodeAccelerator::AssignPictureBuffersTask(
       // If we are using an image processor, the DMABufs that we need to import
       // are those of the image processor's buffers, not the decoders. So
       // pass an empty native pixmap in that case.
+#if !BUILDFLAG(USE_NVIDIA_V4L2)
       if (!image_processor_device_)
         native_pixmap =
             CreateGpuMemoryBufferHandle(video_frame.get()).native_pixmap_handle;
 
       ImportBufferForPictureTask(output_record.picture_id,
                                  std::move(native_pixmap));
+#else
+      ImportBufferForPictureTask(output_record.picture_id,
+                                 std::move(native_pixmap), dmabuf_fd);
+#endif
     }  // else we'll get triggered via ImportBufferForPicture() from client.
 
     DVLOGF(3) << "buffer[" << i << "]: picture_id=" << output_record.picture_id;
@@ -478,6 +499,7 @@ void V4L2VideoDecodeAccelerator::AssignPictureBuffersTask(
   }
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
 void V4L2VideoDecodeAccelerator::CreateEGLImageFor(
     scoped_refptr<V4L2Device> egl_device,
     size_t buffer_index,
@@ -485,7 +507,18 @@ void V4L2VideoDecodeAccelerator::CreateEGLImageFor(
     gfx::NativePixmapHandle handle,
     GLuint texture_id,
     const gfx::Size& visible_size,
+    const Fourcc fourcc,
+    int32_t dmabuf_fd) {
+#else
+  void V4L2VideoDecodeAccelerator::CreateEGLImageFor(
+    scoped_refptr<V4L2Device> egl_device,
+    size_t buffer_index,
+    int32_t picture_buffer_id,
+    gfx::NativePixmapHandle handle,
+    GLuint texture_id,
+    const gfx::Size& visible_size,
     const Fourcc fourcc) {
+#endif
   DVLOGF(3) << "index=" << buffer_index;
   DCHECK(child_task_runner_->BelongsToCurrentThread());
   DCHECK_NE(texture_id, 0u);
@@ -505,9 +538,15 @@ void V4L2VideoDecodeAccelerator::CreateEGLImageFor(
 
   gl::ScopedTextureBinder bind_restore(GL_TEXTURE_EXTERNAL_OES, 0);
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  EGLImageKHR egl_image = egl_device->CreateEGLImage(
+      egl_display_, gl_context->GetHandle(), texture_id, visible_size,
+      buffer_index, fourcc, std::move(handle), dmabuf_fd);
+#else
   EGLImageKHR egl_image = egl_device->CreateEGLImage(
       egl_display_, gl_context->GetHandle(), texture_id, visible_size,
       buffer_index, fourcc, std::move(handle));
+#endif
   if (egl_image == EGL_NO_IMAGE_KHR) {
     LOG(ERROR) << "could not create EGLImageKHR,"
                << " index=" << buffer_index << " texture_id=" << texture_id;
@@ -601,13 +640,23 @@ void V4L2VideoDecodeAccelerator::ImportBufferForPictureForImportTask(
   for (const auto& plane : handle.planes) {
     DVLOGF(3) << ": offset=" << plane.offset << ", stride=" << plane.stride;
   }
-
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  ImportBufferForPictureTask(picture_buffer_id, std::move(handle), -1);
+#else
   ImportBufferForPictureTask(picture_buffer_id, std::move(handle));
+#endif
 }
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+void V4L2VideoDecodeAccelerator::ImportBufferForPictureTask(
+    int32_t picture_buffer_id,
+    gfx::NativePixmapHandle handle,
+    int32_t dmabuf_fd) {
+#else
 void V4L2VideoDecodeAccelerator::ImportBufferForPictureTask(
     int32_t picture_buffer_id,
     gfx::NativePixmapHandle handle) {
+#endif
   DVLOGF(3) << "picture_buffer_id=" << picture_buffer_id
             << ", handle.planes.size()=" << handle.planes.size();
   DCHECK(decoder_thread_.task_runner()->BelongsToCurrentThread());
@@ -728,15 +777,26 @@ void V4L2VideoDecodeAccelerator::ImportBufferForPictureTask(
     // CreateEGLImageFor will run before the picture is passed to the client
     // because the picture will need to be cleared on the child thread first.
     if (!image_processor_) {
+#if !BUILDFLAG(USE_NVIDIA_V4L2)
       DCHECK_GT(handle.planes.size(), 0u);
+#endif
       size_t index = iter - output_buffer_map_.begin();
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+      child_task_runner_->PostTask(
+          FROM_HERE,
+          base::BindOnce(&V4L2VideoDecodeAccelerator::CreateEGLImageFor,
+                         weak_this_, device_, index, picture_buffer_id,
+                         std::move(handle), iter->texture_id, visible_size_,
+                         *egl_image_format_fourcc_, dmabuf_fd));
+#else
       child_task_runner_->PostTask(
           FROM_HERE,
           base::BindOnce(&V4L2VideoDecodeAccelerator::CreateEGLImageFor,
                          weak_this_, device_, index, picture_buffer_id,
                          std::move(handle), iter->texture_id, visible_size_,
                          *egl_image_format_fourcc_));
+#endif
 
       // Early return, AssignEGLImage will make the buffer available for
       // decoding once the EGL image is created.
@@ -768,7 +828,7 @@ void V4L2VideoDecodeAccelerator::ReusePictureBuffer(int32_t picture_buffer_id) {
     }
 
 // TODO(posciak): https://crbug.com/450898.
-#if defined(ARCH_CPU_ARMEL)
+#if defined(ARCH_CPU_ARMEL) || defined(ARCH_CPU_ARM64)
     egl_fence = gl::GLFenceEGL::Create();
     if (!egl_fence) {
       LOG(ERROR) << "gl::GLFenceEGL::Create() failed";
@@ -1260,7 +1320,9 @@ void V4L2VideoDecodeAccelerator::ServiceDeviceTask(bool event_pending) {
             << output_buffer_map_.size() << "] => PROCESSOR["
             << buffers_at_ip_.size() << "] => CLIENT["
             << buffers_at_client_.size() << "]";
-
+            /*
+            << "buffers_awaiting_fence_ " << buffers_awaiting_fence_.size() << "\n";
+            */
   ScheduleDecodeBufferTaskIfNeeded();
   if (resolution_change_pending)
     StartResolutionChange();
@@ -1338,6 +1400,7 @@ void V4L2VideoDecodeAccelerator::Enqueue() {
       } else if (decoder_cmd_supported_) {
         if (!SendDecoderCmdStop())
           return;
+        /* Send an empty buffer instead */
         flush_handled = true;
       }
     }
@@ -1404,7 +1467,11 @@ bool V4L2VideoDecodeAccelerator::DequeueResolutionChangeEvent() {
   DCHECK_NE(decoder_state_, kUninitialized);
   DVLOGF(3);
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  if (base::Optional<struct v4l2_event> event = device_->DequeueEvent()) {
+#else
   while (base::Optional<struct v4l2_event> event = device_->DequeueEvent()) {
+#endif
     if (event->type == V4L2_EVENT_SOURCE_CHANGE) {
       if (event->u.src_change.changes & V4L2_EVENT_SRC_CH_RESOLUTION) {
         VLOGF(2) << "got resolution change event.";
@@ -1467,9 +1534,20 @@ bool V4L2VideoDecodeAccelerator::DequeueOutputBuffer() {
   // completed queue.
   auto ret = output_queue_->DequeueBuffer();
   if (ret.first == false) {
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+    if (flush_awaiting_last_output_buffer_) {
+      flush_awaiting_last_output_buffer_ = false;
+      struct v4l2_decoder_cmd cmd;
+      memset(&cmd, 0, sizeof(cmd));
+      cmd.cmd = V4L2_DEC_CMD_START;
+      IOCTL_OR_ERROR_RETURN_FALSE(VIDIOC_DECODER_CMD, &cmd);
+    }
+    return true;
+#else
     LOG(ERROR) << "Error in Dequeue output buffer";
     NOTIFY_ERROR(PLATFORM_FAILURE);
     return false;
+#endif
   }
   if (!ret.second) {
     return false;
@@ -1720,6 +1798,9 @@ bool V4L2VideoDecodeAccelerator::SendDecoderCmdStop() {
   struct v4l2_decoder_cmd cmd;
   memset(&cmd, 0, sizeof(cmd));
   cmd.cmd = V4L2_DEC_CMD_STOP;
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  cmd.flags = V4L2_DEC_CMD_STOP_TO_BLACK;
+#endif
   IOCTL_OR_ERROR_RETURN_FALSE(VIDIOC_DECODER_CMD, &cmd);
   flush_awaiting_last_output_buffer_ = true;
 
@@ -2612,6 +2693,17 @@ void V4L2VideoDecodeAccelerator::FrameProcessed(
   if (ip_output_record.texture_id != 0 && !ip_output_record.cleared) {
     DCHECK(frame->HasDmaBufs());
 
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+    child_task_runner_->PostTask(
+        FROM_HERE,
+        base::BindOnce(
+            &V4L2VideoDecodeAccelerator::CreateEGLImageFor, weak_this_,
+            image_processor_device_, ip_buffer_index,
+            ip_output_record.picture_id,
+            CreateGpuMemoryBufferHandle(frame.get()).native_pixmap_handle,
+            ip_output_record.texture_id, visible_size_,
+            *egl_image_format_fourcc_, -1));
+#else
     child_task_runner_->PostTask(
         FROM_HERE,
         base::BindOnce(
@@ -2621,6 +2713,7 @@ void V4L2VideoDecodeAccelerator::FrameProcessed(
             CreateGpuMemoryBufferHandle(frame.get()).native_pixmap_handle,
             ip_output_record.texture_id, visible_size_,
             *egl_image_format_fourcc_));
+#endif
   }
 
   // Remove our job from the IP jobs queue
diff --git a/media/gpu/v4l2/v4l2_video_decode_accelerator.h b/media/gpu/v4l2/v4l2_video_decode_accelerator.h
index 1460737..369a6f3 100644
--- a/media/gpu/v4l2/v4l2_video_decode_accelerator.h
+++ b/media/gpu/v4l2/v4l2_video_decode_accelerator.h
@@ -244,8 +244,15 @@ class MEDIA_GPU_EXPORT V4L2VideoDecodeAccelerator
   // Use buffer backed by |handle| for the OutputRecord associated with
   // |picture_buffer_id|. |handle| does not need to be valid if we are in
   // ALLOCATE mode and using an image processor.
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  void ImportBufferForPictureTask(int32_t picture_buffer_id,
+                                  gfx::NativePixmapHandle handle,
+                                  int32_t dmabuf_fd);
+#else
   void ImportBufferForPictureTask(int32_t picture_buffer_id,
                                   gfx::NativePixmapHandle handle);
+#endif
+
 
   // Check |handle| is valid in import mode, besides ImportBufferForPicture.
   void ImportBufferForPictureForImportTask(int32_t picture_buffer_id,
@@ -257,6 +264,16 @@ class MEDIA_GPU_EXPORT V4L2VideoDecodeAccelerator
   // The buffer should be bound to |texture_id| and is of format described by
   // |fourcc|. |visible_size| is the size in pixels that the EGL device will be
   // able to see.
+#if BUILDFLAG(USE_NVIDIA_V4L2)
+  void CreateEGLImageFor(scoped_refptr<V4L2Device> egl_device,
+                         size_t buffer_index,
+                         int32_t picture_buffer_id,
+                         gfx::NativePixmapHandle handle,
+                         GLuint texture_id,
+                         const gfx::Size& visible_size,
+                         const Fourcc fourcc,
+                         int32_t dmabuf_fd);
+#else
   void CreateEGLImageFor(scoped_refptr<V4L2Device> egl_device,
                          size_t buffer_index,
                          int32_t picture_buffer_id,
@@ -264,6 +281,7 @@ class MEDIA_GPU_EXPORT V4L2VideoDecodeAccelerator
                          GLuint texture_id,
                          const gfx::Size& visible_size,
                          const Fourcc fourcc);
+#endif
 
   // Take the EGLImage |egl_image|, created for |picture_buffer_id|, and use it
   // for OutputRecord at |buffer_index|.
diff --git a/media/gpu/v4l2/v4l2_video_decoder.cc b/media/gpu/v4l2/v4l2_video_decoder.cc
index 57530c8..f3701d4 100644
--- a/media/gpu/v4l2/v4l2_video_decoder.cc
+++ b/media/gpu/v4l2/v4l2_video_decoder.cc
@@ -35,10 +35,9 @@ constexpr size_t kNumInputBuffers = 8;
 
 // Input format V4L2 fourccs this class supports.
 constexpr uint32_t kSupportedInputFourccs[] = {
-    V4L2_PIX_FMT_H264,       V4L2_PIX_FMT_VP8,
+    V4L2_PIX_FMT_H264, V4L2_PIX_FMT_VP8, V4L2_PIX_FMT_VP9,
 #if !BUILDFLAG(USE_LINUX_V4L2)
     V4L2_PIX_FMT_H264_SLICE, V4L2_PIX_FMT_VP8_FRAME, V4L2_PIX_FMT_VP9_FRAME,
-    V4L2_PIX_FMT_VP9,
 #endif
 };
 
@@ -222,8 +221,10 @@ void V4L2VideoDecoder::Initialize(const VideoDecoderConfig& config,
     DCHECK_EQ(preferred_api_and_format.first, kStateless);
     VLOGF(1) << "Using a stateless API for profile: " << GetProfileName(profile)
              << " and fourcc: " << FourccToString(input_format_fourcc);
+  #if !BUILDFLAG(USE_NVIDIA_V4L2)
     backend_ = std::make_unique<V4L2StatelessVideoDecoderBackend>(
         this, device_, profile, decoder_task_runner_);
+  #endif
   }
 
   if (!backend_->Initialize()) {
